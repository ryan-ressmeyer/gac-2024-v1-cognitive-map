"""
Path Length (Ocular Drift) Control Analysis for V1 Cognitive Map Study
=======================================================================

This script tests whether differences in ocular drift between attention conditions
could account for observed neural differences.

BACKGROUND:
-----------
Even during attempted fixation, the eyes exhibit slow drift movements. This drift can:
1. Change the retinal image location continuously
2. Activate different populations of neurons with different receptive fields
3. Create apparent "attention" effects if drift patterns differ between conditions

DRIFT QUANTIFICATION:
---------------------
Path length = cumulative eye speed during stimulus period. A sensitive measure of
ocular instability that captures the total distance the eye travels.

HYPOTHESIS:
-----------
If attention effects are due to drift differences, then:
1. Attended and unattended trials should have different path lengths
2. Neural activity should vary systematically with path length
3. Attention effects should disappear when controlling for path length

METHOD:
-------
- Calculate path length (cumulative eye speed) for each trial
- Compare path length distributions between attention conditions
- Divide trials into quartiles based on path length
- Test for attention effects within each path length quartile

DEPENDENCIES:
-------------
- Requires preprocessed_data.h5 generated by preprocessing.py
- numpy, matplotlib, scipy.stats
- pathlib, h5py
- Custom utils module (add_significance_window, significance_connector)

Install dependencies using uv:
    uv sync
    uv run python scripts/analysis_pathlength.py

USAGE:
------
1. First run preprocessing.py to generate preprocessed_data.h5
2. Run this script: python scripts/analysis_pathlength.py

OUTPUTS:
--------
- Path length distribution comparison by attention condition
- Neural activity stratified by path length quartiles
- Statistical tests showing attention effects persist across drift levels
- Figures saved to figures/pathlength/ directory

Author: Ryan Ressmeyer
"""

#%%
import numpy as np
import matplotlib
import matplotlib.pyplot as plt
from pathlib import Path
from scipy.stats import ttest_ind
from utils import add_significance_window, significance_connector, is_notebook, pvalue_to_stars
import h5py
np.random.seed(1001)  # For reproducibility

if is_notebook():
    matplotlib.use('inline')
else:
    matplotlib.use('Qt5Agg')

#%%
# =============================================================================
# CONFIGURATION SECTION
# =============================================================================

# Data paths
DATAGEN_DIR = '/home/ryanress/code/gac-2024-v1-cognitive-map/data/'
PREPROCESSED_DATA_FILE = Path(DATAGEN_DIR) / 'preprocessed_data.h5'

# Analysis parameters
MONKEYS = ['monkeyF', 'monkeyN']
CURRENT_TASK = 'lums'

# Analysis time windows
ATTENTION_WINDOW = [0.15, 0.5]
DRIFT_ANALYSIS_WINDOW = [0, 0.35]  # Time window for path length analysis (s)

# Quartile analysis
N_BINS = 4  # Number of quartiles for stratification

# Figure output
SAVE_FIGS = True
if SAVE_FIGS:
    FIGURE_DIR = Path('./figures/pathlength')
    FIGURE_DIR.mkdir(exist_ok=True, parents=True)

#%%
# =============================================================================
# HELPER FUNCTION
# =============================================================================

def calculate_path_length(eye_speed, trial_attended, t_rel_stim, drift_analysis_window, **kwargs):
    """
    Calculate path length (cumulative eye speed) statistics and quartiles.

    Args:
        eye_speed: Eye speed array [trials x time]
        trial_attended: Binary array indicating attended (1) vs unattended (0) trials
        t_rel_stim: Time vector relative to stimulus onset
        drift_analysis_window: Tuple of (start_time, end_time) for drift analysis
        **kwargs: Additional arguments (ignored, allows passing full data dict)

    Returns:
        trial_path_length: path length for each trial
        quartile_edges: bin edges for quartile analysis
        mean_attended: mean path length for attended trials
        mean_unattended: mean path length for unattended trials
        pvalue: t-test p-value for path length difference
    """
    # Calculate path length for each trial
    drift_mask = (t_rel_stim >= drift_analysis_window[0]) & (t_rel_stim <= drift_analysis_window[1])
    trial_path_length = np.sum(eye_speed[:, drift_mask], axis=1)

    # Calculate quartile edges
    quartile_edges = np.percentile(trial_path_length, np.linspace(0, 100, 5))

    # Calculate means and t-test
    attended_path_length = trial_path_length[trial_attended == 1]
    unattended_path_length = trial_path_length[trial_attended == 0]
    mean_attended = attended_path_length.mean()
    mean_unattended = unattended_path_length.mean()
    pvalue = ttest_ind(attended_path_length, unattended_path_length).pvalue

    return trial_path_length, quartile_edges, mean_attended, mean_unattended, pvalue

#%%
# =============================================================================
# LOAD PREPROCESSED DATA FROM HDF5
# =============================================================================

print("="*70)
print("PATH LENGTH (OCULAR DRIFT) CONTROL ANALYSIS")
print("="*70)
print(f"Loading preprocessed data from: {PREPROCESSED_DATA_FILE}")
print(f"Analyzing monkeys: {', '.join(MONKEYS)}")
print(f"Task: {CURRENT_TASK}")
print("="*70)

# Load data for both monkeys from HDF5
monkey_data = {}

with h5py.File(PREPROCESSED_DATA_FILE, 'r') as f:
    for monkey in MONKEYS:
        monkey_group = f[monkey]

        # Load arrays for this monkey
        monkey_data[monkey] = {
            'population_mua': monkey_group['population_mua'][:],
            'eye_position': monkey_group['eye_position_filtered'][:],
            'eye_velocity': monkey_group['eye_velocity'][:],
            'eye_speed': monkey_group['eye_speed'][:],
            't_rel_stim': monkey_group['t_rel_stim'][:],
            'trial_attended': monkey_group['trial_attended'][:]
        }

# Print summary statistics for both monkeys
print("\nData Summary:")
for monkey in MONKEYS:
    data = monkey_data[monkey]
    total_trials = data['population_mua'].shape[0]
    n_attended = np.sum(data['trial_attended'] == 1)
    n_unattended = np.sum(data['trial_attended'] == 0)

    print(f"\n{monkey}:")
    print(f"   - Total trials: {total_trials}")
    print(f"   - Attended trials: {n_attended}")
    print(f"   - Unattended trials: {n_unattended}")

#%%
# =============================================================================
# CONTROL 3: OCULAR DRIFT (PATH LENGTH) ANALYSIS
# =============================================================================

print("""
Test whether differences in ocular drift between attention conditions could account
for observed neural differences.

BACKGROUND:
Even during attempted fixation, the eyes exhibit slow drift movements. This drift can:
1. Change the retinal image location continuously
2. Activate different populations of neurons with different receptive fields
3. Create apparent "attention" effects if drift patterns differ between conditions

DRIFT QUANTIFICATION:
Path length = cumulative eye speed during stimulus period. A sensitive measure of ocular instability.

HYPOTHESIS: If attention effects are due to drift differences, then:
1. Attended and unattended trials should have different path lengths
2. Neural activity should vary systematically with path length
3. Attention effects should disappear when controlling for path length
""")

print("\n3. CONTROL 3: Ocular drift (path length) analysis...")
print(f"   - Analysis window: {DRIFT_ANALYSIS_WINDOW[0]}-{DRIFT_ANALYSIS_WINDOW[1]} s")

# Calculate path length statistics for both monkeys
path_length_data = {}

for monkey in MONKEYS:
    trial_path_length, edges, mean_att, mean_unatt, pval = calculate_path_length(
        **monkey_data[monkey],
        drift_analysis_window=DRIFT_ANALYSIS_WINDOW
    )

    path_length_data[monkey] = {
        'trial_path_length': trial_path_length,
        'edges': edges,
        'mean_attended': mean_att,
        'mean_unattended': mean_unatt,
        'pval': pval
    }

    print(f'\n{monkey}:')
    print(f'   - Mean attended path length: {mean_att:.2f}')
    print(f'   - Mean unattended path length: {mean_unatt:.2f}')
    print(f'   - T-test for difference in path length: p = {pval:.3f}')
    print(f'   - Path length bin edges (quartiles): {np.round(edges, 2)}')

# Plot the distribution of path lengths for both monkeys (side-by-side)
fig, axes = plt.subplots(1, 2, figsize=(14, 6))

for col_idx, monkey in enumerate(['monkeyN', 'monkeyF']):
    ax = axes[col_idx]
    data = path_length_data[monkey]
    trial_path_length = data['trial_path_length']
    edges = data['edges']
    pval = data['pval']
    mean_att = data['mean_attended']
    mean_unatt = data['mean_unattended']
    trial_attended = monkey_data[monkey]['trial_attended']

    bins = np.linspace(trial_path_length.min(), trial_path_length.max(), 30)
    ax.hist(trial_path_length, bins=bins, color='gray', label='All Trials', alpha=0.6)
    ax.hist(trial_path_length[trial_attended == 1], bins=bins, alpha=0.7, label='Attended', color='r')
    ax.hist(trial_path_length[trial_attended == 0], bins=bins, alpha=0.7, label='Unattended', color='b')

    # Add mean indicators and significance
    ax.scatter([mean_att], [60], color='r', marker='v', s=100, label='Attended Mean', zorder=5)
    ax.scatter([mean_unatt], [60], color='b', marker='v', s=100, label='Unattended Mean', zorder=5)
    pval_text = f'{pvalue_to_stars(pval)}\n' + ('(p={pval:.1e})' if pval < 0.001 else f'(p={pval:.3f})')
    significance_connector(mean_att, mean_unatt, 65, 5, pval_text, ax=ax)

    for e in edges:
        ax.axvline(x=e, color='k', linestyle='--', label='Quartile edges' if e == edges[0] else None, alpha=0.5)

    ax.legend()
    ax.set_title(f'Monkey {monkey[-1].upper()} - Path Lengths ({DRIFT_ANALYSIS_WINDOW[0]}-{DRIFT_ANALYSIS_WINDOW[1]}s)')
    ax.set_xlabel('Path Length (arbitrary units)')
    ax.set_ylabel('Number of Trials')

fig.suptitle('Distribution of Path Lengths', fontsize=16, y=1.00)
plt.tight_layout()
if SAVE_FIGS:
    plt.savefig(FIGURE_DIR / 'path_length_distribution.png', dpi=300)
    plt.savefig(FIGURE_DIR / 'path_length_distribution.svg')
plt.show()

print("\n   - There is no significant difference in path length between attended and unattended trials.")
print("   - Nevertheless, we will check if the attention effect persists within each path length quartile as a stringent control.")

#%%
# Plot MUA for attended vs. unattended trials within each path length quartile
# Layout: 5 rows Ã— 2 columns (MonkeyN left, MonkeyF right)
fig, axs = plt.subplots(N_BINS+1, 2, figsize=(14, 12), sharex=True, sharey=True)
fig.suptitle('MUA Conditioned on Path Length', y=0.995, fontsize=16)

for col_idx, monkey in enumerate(['monkeyN', 'monkeyF']):
    data = monkey_data[monkey]
    path_data = path_length_data[monkey]
    population_mua = data['population_mua']
    trial_attended = data['trial_attended']
    t_rel_stim = data['t_rel_stim']
    trial_path_length = path_data['trial_path_length']
    edges = path_data['edges']

    # Calculate attention window mask
    attention_window_mask = (t_rel_stim >= ATTENTION_WINDOW[0]) & (t_rel_stim <= ATTENTION_WINDOW[1])

    for i in range(N_BINS):
        e0, e1 = edges[i], edges[i+1]
        # Create a mask for trials within the current path length quartile
        quartile_mask = (trial_path_length >= e0) & (trial_path_length <= e1)

        # Calculate MUA for all, attended, and unattended trials in this quartile
        all_mua = population_mua[quartile_mask].mean(axis=0)
        attended_mua = population_mua[quartile_mask & (trial_attended == 1)].mean(axis=0)
        unattended_mua = population_mua[quartile_mask & (trial_attended == 0)].mean(axis=0)

        pval = ttest_ind(
            population_mua[quartile_mask & (trial_attended == 1)][:, attention_window_mask].mean(axis=1),
            population_mua[quartile_mask & (trial_attended == 0)][:, attention_window_mask].mean(axis=1)
        ).pvalue

        # Plotting - row 0 shows all quartiles overlaid
        axs[0, col_idx].plot(t_rel_stim, all_mua, label=f'Q{i+1}')

        # Plotting - rows 1-4 show individual quartiles with attention comparison
        axs[i+1, col_idx].plot(t_rel_stim, all_mua, c='gray', alpha=0.5, label='All trials')
        axs[i+1, col_idx].plot(t_rel_stim, attended_mua, label='Attended', color='r')
        axs[i+1, col_idx].plot(t_rel_stim, unattended_mua, label='Unattended', color='b')
        axs[i+1, col_idx].axvline(x=0, color='k', linestyle='--')
        axs[i+1, col_idx].grid(True, alpha=0.2)
        axs[i+1, col_idx].axhline(y=0, color='k', linestyle='--', alpha=0.3, zorder=0)

        # Add counting window with significance
        add_significance_window(axs[i+1, col_idx], ATTENTION_WINDOW, pval)

        axs[i+1, col_idx].set_title(f'Q{i+1}: [{edges[i]:.2f}, {edges[i+1]:.2f}]')
        if i == 0:
            axs[i+1, col_idx].legend()

    # Configure top row
    axs[0, col_idx].set_title(f'Monkey {monkey[-1].upper()} - All Quartiles')
    axs[0, col_idx].legend()
    axs[0, col_idx].grid(True, alpha=0.2)
    axs[0, col_idx].axvline(x=0, color='k', linestyle='--')

# Set x-labels for bottom row
axs[-1, 0].set_xlabel('Time (s)')
axs[-1, 1].set_xlabel('Time (s)')

# Add y-axis label
fig.text(0.04, 0.5, 'Normalized MUA', va='center', rotation='vertical', fontsize=12)
plt.tight_layout(rect=[0.05, 0, 1, 0.99])
if SAVE_FIGS:
    plt.savefig(FIGURE_DIR / 'mua_by_path_length_quartile.png', dpi=300)
    plt.savefig(FIGURE_DIR / 'mua_by_path_length_quartile.svg')
plt.show()

print("\n" + "="*70)
print("KEY FINDING: Attention effects persist across all path length quartiles.")
print("="*70)
print("\nINTERPRETATION:")
print("- Although there is a slight modulation of MUA by path length (higher drift")
print("  = slightly higher MUA), the attention effect is robustly present in all quartiles.")
print("- This demonstrates that neural attention effects are not mere artifacts of")
print("  ocular drift.")
print("\nCONCLUSION for Control 3 (Path Length/Drift):")
print("The attentional modulation of V1 multi-unit activity is not driven by")
print("differences in ocular drift between attended and unattended conditions.")
print("="*70)

print("\n" + "="*70)
print("SUMMARY OF EYE MOVEMENT CONTROLS")
print("="*70)
print("The three comprehensive eye movement controls demonstrate that:")
print("1. MICROSACCADE CONTROL: Attention effects remain in trials without microsaccades.")
print("2. EYE POSITION CONTROL: Attention effects persist within each eye position quartile.")
print("3. DRIFT CONTROL: Attention effects are present across all ocular drift levels.")
print()
print("CONCLUSION:")
print("These controls were unable to explain away the V1 attentional effects as being")
print("due to eye movements during fixation.")
print("="*70)
