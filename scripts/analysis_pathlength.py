"""
Path Length (Ocular Drift) Control Analysis for V1 Cognitive Map Study
=======================================================================

This script tests whether differences in ocular drift between attention conditions
could account for observed neural differences.

BACKGROUND:
-----------
Even during attempted fixation, the eyes exhibit slow drift movements. This drift can:
1. Change the retinal image location continuously
2. Activate different populations of neurons with different receptive fields
3. Create apparent "attention" effects if drift patterns differ between conditions

DRIFT QUANTIFICATION:
---------------------
Path length = cumulative eye speed during stimulus period. A sensitive measure of
ocular instability that captures the total distance the eye travels.

HYPOTHESIS:
-----------
If attention effects are due to drift differences, then:
1. Attended and unattended trials should have different path lengths
2. Neural activity should vary systematically with path length
3. Attention effects should disappear when controlling for path length

METHOD:
-------
- Calculate path length (cumulative eye speed) for each trial
- Compare path length distributions between attention conditions
- Divide trials into quartiles based on path length
- Test for attention effects within each path length quartile

DEPENDENCIES:
-------------
- Requires preprocessed_data.h5 generated by preprocessing.py
- numpy, matplotlib, scipy.stats
- pathlib, h5py
- Custom utils module (add_significance_window, significance_connector)

Install dependencies using uv:
    uv sync
    uv run python scripts/analysis_pathlength.py

USAGE:
------
1. First run preprocessing.py to generate preprocessed_data.h5
2. Run this script: python scripts/analysis_pathlength.py

OUTPUTS:
--------
- Path length distribution comparison by attention condition
- Neural activity stratified by path length quartiles
- Statistical tests showing attention effects persist across drift levels
- Figures saved to figures/pathlength/ directory

Author: Ryan Ressmeyer
"""

#%%
import numpy as np
import matplotlib
import matplotlib.pyplot as plt
from pathlib import Path
from scipy.stats import ttest_ind
from utils import add_significance_window, significance_connector, is_notebook, pvalue_to_stars
import h5py
np.random.seed(1001)  # For reproducibility

if is_notebook():
    matplotlib.use('inline')
else:
    matplotlib.use('Qt5Agg')

#%%
# =============================================================================
# CONFIGURATION SECTION
# =============================================================================

# Data paths
DATAGEN_DIR = '/home/ryanress/code/gac-2024-v1-cognitive-map/data/'
PREPROCESSED_DATA_FILE = Path(DATAGEN_DIR) / 'preprocessed_data.h5'

# Analysis parameters
MONKEYS = ['monkeyF', 'monkeyN']
CURRENT_TASK = 'lums'

# Analysis time windows
ATTENTION_WINDOW = [0.15, 0.5]
DRIFT_ANALYSIS_WINDOW = [0, 0.35]  # Time window for path length analysis (s)

# Quartile analysis
N_BINS = 4  # Number of quartiles for stratification

# Figure output
SAVE_FIGS = True
if SAVE_FIGS:
    FIGURE_DIR = Path('./figures/pathlength')
    FIGURE_DIR.mkdir(exist_ok=True, parents=True)

#%%
# =============================================================================
# HELPER FUNCTION
# =============================================================================

def calculate_path_length(eye_speed, trial_attended, t_rel_stim, drift_analysis_window, **kwargs):
    """
    Calculate path length (cumulative eye speed) statistics and quartiles.

    Args:
        eye_speed: Eye speed array [trials x time] in deg/s
        trial_attended: Binary array indicating attended (1) vs unattended (0) trials
        t_rel_stim: Time vector relative to stimulus onset
        drift_analysis_window: Tuple of (start_time, end_time) for drift analysis
        **kwargs: Additional arguments (ignored, allows passing full data dict)

    Returns:
        trial_path_length: path length for each trial in degrees
        quartile_edges: bin edges for quartile analysis
        mean_attended: mean path length for attended trials
        mean_unattended: mean path length for unattended trials
        pvalue: t-test p-value for path length difference
    """
    # Calculate dt from the time vector
    dt = t_rel_stim[1] - t_rel_stim[0]

    # Calculate path length for each trial (integrate speed over time to get distance in degrees)
    drift_mask = (t_rel_stim >= drift_analysis_window[0]) & (t_rel_stim <= drift_analysis_window[1])
    trial_path_length = np.sum(eye_speed[:, drift_mask], axis=1) * dt

    # Calculate quartile edges
    quartile_edges = np.percentile(trial_path_length, np.linspace(0, 100, 5))

    # Calculate means and t-test
    attended_path_length = trial_path_length[trial_attended == 1]
    unattended_path_length = trial_path_length[trial_attended == 0]
    mean_attended = attended_path_length.mean()
    mean_unattended = unattended_path_length.mean()
    pvalue = ttest_ind(attended_path_length, unattended_path_length).pvalue

    return trial_path_length, quartile_edges, mean_attended, mean_unattended, pvalue

#%%
# =============================================================================
# LOAD PREPROCESSED DATA FROM HDF5
# =============================================================================

print("="*70)
print("PATH LENGTH (OCULAR DRIFT) CONTROL ANALYSIS")
print("="*70)
print(f"Loading preprocessed data from: {PREPROCESSED_DATA_FILE}")
print(f"Analyzing monkeys: {', '.join(MONKEYS)}")
print(f"Task: {CURRENT_TASK}")
print("="*70)

# Load data for both monkeys from HDF5
monkey_data = {}

with h5py.File(PREPROCESSED_DATA_FILE, 'r') as f:
    for monkey in MONKEYS:
        monkey_group = f[monkey]

        # Load arrays for this monkey
        monkey_data[monkey] = {
            'population_mua': monkey_group['population_mua'][:],
            'eye_position': monkey_group['eye_position_filtered'][:],
            'eye_velocity': monkey_group['eye_velocity'][:],
            'eye_speed': monkey_group['eye_speed'][:],
            't_rel_stim': monkey_group['t_rel_stim'][:],
            'trial_attended': monkey_group['trial_attended'][:]
        }

# Print summary statistics for both monkeys
print("\nData Summary:")
for monkey in MONKEYS:
    data = monkey_data[monkey]
    total_trials = data['population_mua'].shape[0]
    n_attended = np.sum(data['trial_attended'] == 1)
    n_unattended = np.sum(data['trial_attended'] == 0)

    print(f"\n{monkey}:")
    print(f"   - Total trials: {total_trials}")
    print(f"   - Attended trials: {n_attended}")
    print(f"   - Unattended trials: {n_unattended}")

#%%
# =============================================================================
# CONTROL 3: OCULAR DRIFT (PATH LENGTH) ANALYSIS
# =============================================================================

print("""
Test whether differences in ocular drift between attention conditions could account
for observed neural differences.

BACKGROUND:
Even during attempted fixation, the eyes exhibit slow drift movements. This drift can:
1. Change the retinal image location continuously
2. Activate different populations of neurons with different receptive fields
3. Create apparent "attention" effects if drift patterns differ between conditions

DRIFT QUANTIFICATION:
Path length = cumulative eye speed during stimulus period. A sensitive measure of ocular instability.

HYPOTHESIS: If attention effects are due to drift differences, then:
1. Attended and unattended trials should have different path lengths
2. Neural activity should vary systematically with path length
3. Attention effects should disappear when controlling for path length
""")

print("\n3. CONTROL 3: Ocular drift (path length) analysis...")
print(f"   - Analysis window: {DRIFT_ANALYSIS_WINDOW[0]}-{DRIFT_ANALYSIS_WINDOW[1]} s")

# Calculate path length statistics for both monkeys
path_length_data = {}

for monkey in MONKEYS:
    trial_path_length, edges, mean_att, mean_unatt, pval = calculate_path_length(
        **monkey_data[monkey],
        drift_analysis_window=DRIFT_ANALYSIS_WINDOW
    )

    path_length_data[monkey] = {
        'trial_path_length': trial_path_length,
        'edges': edges,
        'mean_attended': mean_att,
        'mean_unattended': mean_unatt,
        'pval': pval
    }

    print(f'\n{monkey}:')
    print(f'   - Mean attended path length: {mean_att:.2f}')
    print(f'   - Mean unattended path length: {mean_unatt:.2f}')
    print(f'   - T-test for difference in path length: p = {pval:.3f}')
    print(f'   - Path length bin edges (quartiles): {np.round(edges, 2)}')

# Plot the distribution of path lengths for both monkeys (side-by-side)
fig, axes = plt.subplots(1, 2, figsize=(14, 6))

for col_idx, monkey in enumerate(['monkeyN', 'monkeyF']):
    ax = axes[col_idx]
    data = path_length_data[monkey]
    trial_path_length = data['trial_path_length']
    edges = data['edges']
    pval = data['pval']
    mean_att = data['mean_attended']
    mean_unatt = data['mean_unattended']
    trial_attended = monkey_data[monkey]['trial_attended']

    bins = np.linspace(trial_path_length.min(), trial_path_length.max(), 30)
    ax.hist(trial_path_length, bins=bins, color='gray', label='All Trials', alpha=0.6)
    ax.hist(trial_path_length[trial_attended == 1], bins=bins, alpha=0.7, label='Attended', color='r')
    ax.hist(trial_path_length[trial_attended == 0], bins=bins, alpha=0.7, label='Unattended', color='b')

    # Add mean indicators and significance
    ax.scatter([mean_att], [60], color='r', marker='v', s=100, label='Attended Mean', zorder=5)
    ax.scatter([mean_unatt], [60], color='b', marker='v', s=100, label='Unattended Mean', zorder=5)
    pval_text = f'{pvalue_to_stars(pval)}\n' + ('(p={pval:.1e})' if pval < 0.001 else f'(p={pval:.3f})')
    significance_connector(mean_att, mean_unatt, 65, 5, pval_text, ax=ax)

    for e in edges:
        ax.axvline(x=e, color='k', linestyle='--', label='Quartile edges' if e == edges[0] else None, alpha=0.5)

    ax.legend()
    ax.set_title(f'Monkey {monkey[-1].upper()} - Path Lengths ({DRIFT_ANALYSIS_WINDOW[0]}-{DRIFT_ANALYSIS_WINDOW[1]}s)')
    ax.set_xlabel('Path Length (degrees)')
    ax.set_ylabel('Number of Trials')

fig.suptitle('Distribution of Path Lengths', fontsize=16, y=1.00)
plt.tight_layout()
if SAVE_FIGS:
    plt.savefig(FIGURE_DIR / 'path_length_distribution.png', dpi=300)
    plt.savefig(FIGURE_DIR / 'path_length_distribution.svg')
plt.show()

print("\n   - There is no significant difference in path length between attended and unattended trials.")
print("   - Nevertheless, we will check if the attention effect persists within each path length quartile as a stringent control.")

#%%
# Plot MUA for attended vs. unattended trials within each path length quartile
# Layout: 5 rows × 2 columns (MonkeyN left, MonkeyF right)
fig, axs = plt.subplots(N_BINS+1, 2, figsize=(14, 12), sharex=True, sharey=True)
fig.suptitle('MUA Conditioned on Path Length', y=0.995, fontsize=16)

for col_idx, monkey in enumerate(['monkeyN', 'monkeyF']):
    data = monkey_data[monkey]
    path_data = path_length_data[monkey]
    population_mua = data['population_mua']
    trial_attended = data['trial_attended']
    t_rel_stim = data['t_rel_stim']
    trial_path_length = path_data['trial_path_length']
    edges = path_data['edges']

    # Calculate attention window mask
    attention_window_mask = (t_rel_stim >= ATTENTION_WINDOW[0]) & (t_rel_stim <= ATTENTION_WINDOW[1])

    for i in range(N_BINS):
        e0, e1 = edges[i], edges[i+1]
        # Create a mask for trials within the current path length quartile
        quartile_mask = (trial_path_length >= e0) & (trial_path_length <= e1)

        # Calculate MUA for all, attended, and unattended trials in this quartile
        all_mua = population_mua[quartile_mask].mean(axis=0)
        attended_mua = population_mua[quartile_mask & (trial_attended == 1)].mean(axis=0)
        unattended_mua = population_mua[quartile_mask & (trial_attended == 0)].mean(axis=0)

        pval = ttest_ind(
            population_mua[quartile_mask & (trial_attended == 1)][:, attention_window_mask].mean(axis=1),
            population_mua[quartile_mask & (trial_attended == 0)][:, attention_window_mask].mean(axis=1)
        ).pvalue

        # Plotting - row 0 shows all quartiles overlaid
        axs[0, col_idx].plot(t_rel_stim, all_mua, label=f'Q{i+1}')

        # Plotting - rows 1-4 show individual quartiles with attention comparison
        axs[i+1, col_idx].plot(t_rel_stim, all_mua, c='gray', alpha=0.5, label='All trials')
        axs[i+1, col_idx].plot(t_rel_stim, attended_mua, label='Attended', color='r')
        axs[i+1, col_idx].plot(t_rel_stim, unattended_mua, label='Unattended', color='b')
        axs[i+1, col_idx].axvline(x=0, color='k', linestyle='--')
        axs[i+1, col_idx].grid(True, alpha=0.2)
        axs[i+1, col_idx].axhline(y=0, color='k', linestyle='--', alpha=0.3, zorder=0)

        # Add counting window with significance
        add_significance_window(axs[i+1, col_idx], ATTENTION_WINDOW, pval)

        axs[i+1, col_idx].set_title(f'Q{i+1}: [{edges[i]:.2f}, {edges[i+1]:.2f}]')
        if i == 0:
            axs[i+1, col_idx].legend()

    # Configure top row
    axs[0, col_idx].set_title(f'Monkey {monkey[-1].upper()} - All Quartiles')
    axs[0, col_idx].legend()
    axs[0, col_idx].grid(True, alpha=0.2)
    axs[0, col_idx].axvline(x=0, color='k', linestyle='--')

# Set x-labels for bottom row
axs[-1, 0].set_xlabel('Time (s)')
axs[-1, 1].set_xlabel('Time (s)')

# Add y-axis label
fig.text(0.04, 0.5, 'Normalized MUA', va='center', rotation='vertical', fontsize=12)
plt.tight_layout(rect=[0.05, 0, 1, 0.99])
if SAVE_FIGS:
    plt.savefig(FIGURE_DIR / 'mua_by_path_length_quartile.png', dpi=300)
    plt.savefig(FIGURE_DIR / 'mua_by_path_length_quartile.svg')
plt.show()

#%%
# =============================================================================
# COMBINED CONTROL: Full Interaction Regression Plot
# =============================================================================
try:
    # Use the formula API for easier model specification
    import statsmodels.formula.api as smf
    import pandas as pd
except ImportError:
    print("\n---")
    print("ERROR: This analysis requires 'statsmodels' and 'pandas'.")
    print("Please install them by running: uv pip install statsmodels pandas")
    print("---")
    raise

print("\n" + "="*70)
print("Combined Control: Multiple Linear Regression with Interaction")
print("="*70)
print("Testing main effects and interaction effects in one model.")
print("Model: MUA_mean ~ β₁*attention + β₂*path_length + β₃*(attention*path_length)")

# This will store the results text for each monkey
interaction_regression_summaries = {}

for monkey in MONKEYS:
    print(f"\n--- Analyzing {monkey} ---")

    data = monkey_data[monkey]
    path_data = path_length_data[monkey]

    # 1. Prepare the Dependent Variable (Y): Mean MUA
    t_rel_stim = data['t_rel_stim']
    attention_window_mask = (t_rel_stim >= ATTENTION_WINDOW[0]) & (t_rel_stim <= ATTENTION_WINDOW[1])
    trial_mua_mean = data['population_mua'][:, attention_window_mask].mean(axis=1)

    # 2. Prepare the Independent Variables (X)
    trial_attended = data['trial_attended']
    trial_path_length = path_data['trial_path_length']

    # Demean path_length for regression (centering at mean)
    path_length_mean = trial_path_length.mean()
    trial_path_length_demeaned = trial_path_length - path_length_mean

    # 3. Create a Pandas DataFrame
    df = pd.DataFrame({
        'mua_mean': trial_mua_mean,
        'attention': trial_attended,
        'path_length': trial_path_length_demeaned,
        'path_length_raw': trial_path_length  # Keep raw values for plotting
    })

    # 4. Define and Fit the Model (using demeaned path_length)
    model = smf.ols(formula='mua_mean ~ attention * path_length', data=df).fit()

    # 5. Print and store the results
    print(model.summary())
    interaction_regression_summaries[monkey] = model.summary()

    # 6. Get key results for interpretation
    p_val_attn = model.pvalues['attention']
    p_val_path = model.pvalues['path_length']
    p_val_interact = model.pvalues['attention:path_length']

    print("\n--- Interpretation ---")
    print(f"p-value for β₁ (Attention): {p_val_attn:.3f}")
    print(f"p-value for β₂ (Path Length): {p_val_path:.3f}")
    print(f"p-value for β₃ (Interaction): {p_val_interact:.3f}")

    if p_val_interact < 0.05:
        print("CONCLUSION: The interaction is STATISTICALLY SIGNIFICANT (p < 0.05)")
    else:
        print("CONCLUSION: The interaction is NOT statistically significant (p >= 0.05)")
    print("="*70)

    # Store data for combined plotting
    if monkey == MONKEYS[0]:
        monkey_regression_data = {}

    monkey_regression_data[monkey] = {
        'df': df,
        'model': model,
        'p_val_attn': p_val_attn,
        'p_val_path': p_val_path,
        'p_val_interact': p_val_interact,
        'path_length_mean': path_length_mean
    }

# ==========================================================
# --- COMBINED PRESENTATION PLOT ---
# ==========================================================

print("\n   Generating combined presentation plot with 95% CI for both monkeys...")

fig, axes = plt.subplots(1, 2, figsize=(12, 6))

# Helper function to format p-values
def format_p(p_val):
    if p_val < 0.001:
        return "p < 0.001"
    else:
        return f"p = {p_val:.3f}"

for col_idx, monkey in enumerate(['monkeyN', 'monkeyF']):
    ax = axes[col_idx]

    # Get stored data
    data_dict = monkey_regression_data[monkey]
    df = data_dict['df']
    model = data_dict['model']
    p_val_attn = data_dict['p_val_attn']
    p_val_path = data_dict['p_val_path']
    p_val_interact = data_dict['p_val_interact']
    path_length_mean = data_dict['path_length_mean']

    # 1. Plot the raw data points (using raw path_length for x-axis)
    ax.scatter(df[df['attention'] == 0]['path_length_raw'], df[df['attention'] == 0]['mua_mean'],
               c='b', alpha=0.15, label='Unattended Trials', s=15)
    ax.scatter(df[df['attention'] == 1]['path_length_raw'], df[df['attention'] == 1]['mua_mean'],
               c='r', alpha=0.15, label='Attended Trials', s=15)

    # 2. Generate prediction dataframes (use demeaned values for prediction, raw for plotting)
    x_line_raw = np.linspace(df['path_length_raw'].min(), df['path_length_raw'].max(), 100)
    x_line_demeaned = x_line_raw - path_length_mean
    unattn_pred_data = pd.DataFrame({'path_length': x_line_demeaned, 'attention': np.zeros(100)})
    attn_pred_data = pd.DataFrame({'path_length': x_line_demeaned, 'attention': np.ones(100)})

    # 3. Get predictions and 95% confidence intervals
    unattn_pred = model.get_prediction(unattn_pred_data)
    unattn_ci = unattn_pred.summary_frame(alpha=0.05)

    attn_pred = model.get_prediction(attn_pred_data)
    attn_ci = attn_pred.summary_frame(alpha=0.05)

    # 4. Plot the regression lines (use raw x values for plotting)
    ax.plot(x_line_raw, unattn_ci['mean'], 'b', linewidth=3, label='Unattended Fit')
    ax.plot(x_line_raw, attn_ci['mean'], 'r', linewidth=3, label='Attended Fit')

    # 5. Plot the 95% confidence intervals (use raw x values for plotting)
    ax.fill_between(x_line_raw,
                    unattn_ci['mean_ci_lower'],
                    unattn_ci['mean_ci_upper'],
                    color='b', alpha=0.15, label='95% CI')

    ax.fill_between(x_line_raw,
                    attn_ci['mean_ci_lower'],
                    attn_ci['mean_ci_upper'],
                    color='r', alpha=0.15, label='95% CI')

    # 6. Add p-value text box with note about centering
    text_str = (f"β₁ (Attention): {format_p(p_val_attn)}\n"
                f"β₂ (Path Length):  {format_p(p_val_path)}\n"
                f"β₃ (Interaction): {format_p(p_val_interact)}\n"
                f"(βs at mean path length: {path_length_mean:.3f}°)")

    ax.text(0.04, 0.96, text_str,
            transform=ax.transAxes,
            ha='left', va='top', fontsize=11,
            bbox=dict(facecolor='white', alpha=0.8, boxstyle='round,pad=0.5'))

    # Consolidate legends
    handles, labels = ax.get_legend_handles_labels()
    # Remove duplicate CI label
    by_label = dict(zip(labels, handles))
    if monkey == 'monkeyN':
        ax.legend(by_label.values(), by_label.keys(), loc='lower right')

    ax.set_xlabel('Path Length (degrees)')
    ax.set_ylabel(f'Mean Normalized MUA ({ATTENTION_WINDOW[0]}-{ATTENTION_WINDOW[1]}s)')
    ax.set_title(f'Monkey {monkey[-1].upper()}')
    ax.grid(True, alpha=0.3)

fig.suptitle('MUA = β₀ + (β₁ × Attention) + (β₂ × Path_Length) + (β₃ × Attention × Path_Length)',
             fontsize=14, y=0.98)
plt.tight_layout()

if SAVE_FIGS:
    fig.savefig(FIGURE_DIR / 'mua_vs_pathlength_interaction_summary_combined.png', dpi=300)
    fig.savefig(FIGURE_DIR / 'mua_vs_pathlength_interaction_summary_combined.svg')
plt.show()

# Save the full text summaries to a file
if SAVE_FIGS:
    summary_path = FIGURE_DIR / 'interaction_regression_summary.txt'
    print(f"\nSaving full interaction regression summaries to: {summary_path}")
    with open(summary_path, 'w') as f:
        f.write("Interaction Regression Summary: Monkey N\n")
        f.write(str(interaction_regression_summaries.get('monkeyN', 'Not run.')))
        f.write("\n\n" + "="*80 + "\n\n")
        f.write("Interaction Regression Summary: Monkey F\n")
        f.write(str(interaction_regression_summaries.get('monkeyF', 'Not run.')))

print("\nInteraction regression analysis complete.")
print("="*70)

#%%
print("\n" + "="*70)
print("KEY FINDING: Attention effects persist across all path length quartiles.")
print("="*70)
print("\nINTERPRETATION:")
print("- Although there is a slight modulation of MUA by path length (higher drift")
print("  = slightly higher MUA), the attention effect is robustly present in all quartiles.")
print("- This demonstrates that neural attention effects are not mere artifacts of")
print("  ocular drift.")
print("\nCONCLUSION for Control 3 (Path Length/Drift):")
print("The attentional modulation of V1 multi-unit activity is not driven by")
print("differences in ocular drift between attended and unattended conditions.")
print("="*70)

print("\n" + "="*70)
print("SUMMARY OF EYE MOVEMENT CONTROLS")
print("="*70)
print("The three comprehensive eye movement controls demonstrate that:")
print("1. MICROSACCADE CONTROL: Attention effects remain in trials without microsaccades.")
print("2. EYE POSITION CONTROL: Attention effects persist within each eye position quartile.")
print("3. DRIFT CONTROL: Attention effects are present across all ocular drift levels.")
print()
print("CONCLUSION:")
print("These controls were unable to explain away the V1 attentional effects as being")
print("due to eye movements during fixation.")
print("="*70)
