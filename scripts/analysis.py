"""
Eye Movement Control Analysis for V1 Cognitive Map Study
=========================================================

This script loads preprocessed neural and eye tracking data from HDF5 and runs
three comprehensive eye movement control analyses to demonstrate that attentional
modulation of V1 activity is not driven by eye movements.

ANALYSES:
---------
0. Baseline Attention Effect: Establish the core attention effect
1. Eye Position Control: Tests whether mean gaze position differences explain neural effects
2. Microsaccade Control: Excludes trials with microsaccades during stimulus presentation
3. Drift Control (Path Length): Controls for overall ocular drift

DEPENDENCIES:
-------------
- Requires preprocessed_data.h5 generated by preprocessing.py
- numpy, matplotlib, scipy (signal processing)
- pathlib (file handling)
- tqdm (progress bars)
- Custom utils module (smooth, significance_connector)

Install dependencies using uv:
    uv sync
    uv run python scripts/analysis.py

USAGE:
------
1. First run preprocessing.py to generate preprocessed_data.h5
2. Configure CURRENT_MONKEY parameter below
3. Run this script: python scripts/analysis.py

OUTPUTS:
--------
- Statistical comparisons of eye movements between attention conditions
- Microsaccade detection and timing visualizations
- Neural activity plots stratified by eye movement controls
- Demonstrates persistence of attention effects after controlling for eye movements

Author: Ryan Ressmeyer
"""

#%%
import numpy as np
import matplotlib
import matplotlib.pyplot as plt
from pathlib import Path
from scipy.signal import find_peaks
from scipy.stats import ttest_ind
from matplotlib.backends.backend_pdf import PdfPages
from tqdm import tqdm
from utils import significance_connector, is_notebook
import h5py
np.random.seed(104) # For reproducibility

if is_notebook():
    matplotlib.use('inline')
else:
    matplotlib.use('Qt5Agg')

# =============================================================================
# CONFIGURATION SECTION
# =============================================================================
# **IMPORTANT**: Update this path to your preprocessed data file
DATAGEN_DIR = '/home/ryanress/code/gac-2024-v1-cognitive-map/data/'
PREPROCESSED_DATA_FILE = Path(DATAGEN_DIR) / 'preprocessed_data.h5'

# Analysis parameters
MONKEYS = ['monkeyF', 'monkeyN']
CURRENT_MONKEY = 'monkeyF'  # Switch between 'monkeyF' and 'monkeyN'
CURRENT_TASK = 'lums'

# Microsaccade detection parameters
MICROSACCADE_THRESHOLD = 0.35  # Velocity threshold (deg/s)
MIN_SACCADE_INTERVAL = 100  # Minimum time between saccades (ms at 1kHz = samples)
EXPORT_SACCADE_PDF = False  # Export PDF with microsaccade detection for inspection

# Analysis time windows
ATTENTION_WINDOW = [0.15, 0.5]
MICROSACCADE_WINDOW = [0, 0.5]  # Time window for microsaccade exclusion (s)
DRIFT_ANALYSIS_WINDOW = [0, 0.3]  # Time window for path length analysis (s)
EYE_POSITION_WINDOW = [0.3, 0.4]  # Time window for mean position analysis (s)

# Figure output
SAVE_FIGS = True
if SAVE_FIGS:
    FIGURE_DIR = Path('./figures/analysis')
    FIGURE_DIR.mkdir(exist_ok=True, parents=True)

#%%
# =============================================================================
# LOAD PREPROCESSED DATA FROM HDF5
# =============================================================================

print("="*70)
print("EYE MOVEMENT CONTROL ANALYSIS")
print("="*70)
print(f"Loading preprocessed data from: {PREPROCESSED_DATA_FILE}")
print(f"Analyzing monkey: {CURRENT_MONKEY}")
print(f"Task: {CURRENT_TASK}")
print("="*70)

# Load data from HDF5
with h5py.File(PREPROCESSED_DATA_FILE, 'r') as f:
    monkey_data = f[CURRENT_MONKEY]

    # Load arrays
    population_mua = monkey_data['population_mua'][:]
    eye_position = monkey_data['eye_position_filtered'][:]
    eye_velocity = monkey_data['eye_velocity'][:]
    eye_speed = monkey_data['eye_speed'][:]
    t_rel_stim = monkey_data['t_rel_stim'][:]
    trial_attended = monkey_data['trial_attended'][:]

# Compute trial masks and indices
total_trials = population_mua.shape[0]
attended_trials_mask = trial_attended == 1
unattended_trials_mask = trial_attended == 0
attended_trial_indices = np.where(attended_trials_mask)[0]
unattended_trial_indices = np.where(unattended_trials_mask)[0]

print(f"\n   - Loaded {total_trials} trials")
print(f"   - Attended trials: {len(attended_trial_indices)}")
print(f"   - Unattended trials: {len(unattended_trial_indices)}")
print(f"   - Population MUA shape: {population_mua.shape}")
print(f"   - Eye data shape: {eye_position.shape}")

#%%
# =============================================================================
# BASELINE NEURAL ATTENTION EFFECT
# =============================================================================
print("""
This section establishes the core attention effect that we will control for.

ANALYSIS: Compare average neural activity between attended and unattended trials
- This is the primary effect we want to show persists after eye movement controls
- Provides the baseline against which we will compare controlled analyses
""")

print("\n1. Analyzing baseline attention effect on neural activity...")

# Calculate attention effect: attended vs unattended average responses
all_population_mua = population_mua.mean(axis=0)
attended_population_mua = population_mua[attended_trial_indices].mean(axis=0)
unattended_population_mua = population_mua[unattended_trial_indices].mean(axis=0)

print(f"   - Attended trials: {len(attended_trial_indices)} trials")
print(f"   - Unattended trials: {len(unattended_trial_indices)} trials")

# Create the baseline attention effect plot
plt.figure()
plt.plot(t_rel_stim, all_population_mua, color='gray', label='All Trials', alpha=0.7)
plt.plot(t_rel_stim, unattended_population_mua, color='b', linewidth=2, label='Unattended')
plt.plot(t_rel_stim, attended_population_mua, color='r', linewidth=2, label='Attended')
plt.axvline(x=0, color='k', linestyle='--', linewidth=1)
plt.grid()
plt.xlabel('Time (s)')
plt.ylabel('Normalized MUA')
plt.legend()
plt.title(f'{CURRENT_MONKEY.capitalize()} - Baseline Attention Effect')
if SAVE_FIGS:
    plt.savefig(FIGURE_DIR / f'{CURRENT_MONKEY}_baseline_attention_effect.png', dpi=300)
    plt.savefig(FIGURE_DIR / f'{CURRENT_MONKEY}_baseline_attention_effect.svg')
plt.show()

# Calculate and report attention effect magnitude
attention_window_mask = (t_rel_stim >= ATTENTION_WINDOW[0]) & (t_rel_stim <= ATTENTION_WINDOW[1])
attended_population_mua_window = population_mua[attended_trial_indices][:,attention_window_mask].mean(axis=1)
unattended_population_mua_window = population_mua[unattended_trial_indices][:,attention_window_mask].mean(axis=1)
attention_pvalue = ttest_ind(attended_population_mua_window, unattended_population_mua_window).pvalue
print(f'   - Mean attended activity: {attended_population_mua_window.mean():.3f}')
print(f'   - Mean unattended activity: {unattended_population_mua_window.mean():.3f}')
print(f'   - Attention effect magnitude (mean difference): {attended_population_mua_window.mean() - unattended_population_mua_window.mean():.3f}')
print(f'   - Mean attention effect p-value (t-test): {attention_pvalue:.3e}')

#%%
# =============================================================================
# Visualize Sample Eye Position Trials
# =============================================================================

print("\n   Visualizing sample eye position trials...")

n_trials_to_plot = 5
attn_plot = np.random.permutation(attended_trial_indices)[:n_trials_to_plot]
unattn_plot = np.random.permutation(unattended_trial_indices)[:n_trials_to_plot]
t_mask = (0 < t_rel_stim) & (t_rel_stim < 0.5)
bins = np.linspace(-1, 1, 100)  # Position bins in degrees
ep_unattn = eye_position[unattn_plot]
ep_unattn_all = eye_position[unattended_trial_indices]
ep_attn = eye_position[attn_plot]
ep_attn_all = eye_position[attended_trial_indices]

fig, axs = plt.subplots(1, 3, figsize=(15, 5))

# Panel 1: X Position
axs[0].plot(t_rel_stim, ep_unattn[:,:,0].T, alpha=0.7, c='b', linewidth=1)
axs[0].plot(t_rel_stim, ep_attn[:,:,0].T, alpha=0.7, c='r', linewidth=1)
axs[0].axvline(x=0, color='k', linestyle='--', linewidth=1.5, label='Stimulus Onset')
axs[0].set_title('X Position')
axs[0].set_ylabel('Position (degrees)')
axs[0].set_xlabel('Time (s)')
axs[0].set_ylim(-1, 1)
axs[0].grid(True, alpha=0.3)
lines = [
    matplotlib.lines.Line2D([0], [0], color='b', lw=2, alpha=0.7),
    matplotlib.lines.Line2D([0], [0], color='r', lw=2, alpha=0.7),
    matplotlib.lines.Line2D([0], [0], color='k', lw=1.5, linestyle='--')
]
axs[0].legend(lines, ['Unattended Trials', 'Attended Trials', 'Stimulus Onset'])

# Panel 2: Y Position
axs[1].plot(t_rel_stim, ep_unattn[:,:,1].T, alpha=0.5, c='b', linewidth=1)
axs[1].plot(t_rel_stim, ep_attn[:,:,1].T, alpha=0.5, c='r', linewidth=1)
axs[1].axvline(x=0, color='k', linestyle='--', linewidth=1.5)
axs[1].set_title('Y Position')
axs[1].set_ylabel('Position (degrees)')
axs[1].set_xlabel('Time (s)')
axs[1].set_ylim(-1, 1)
axs[1].grid(True, alpha=0.3)

# Panel 3: 2D Histogram of all trials (0-500ms window)
ep_all_trials = eye_position[:, t_mask, :]
h = axs[2].hist2d(ep_all_trials[:,:,0].flatten(),
                   ep_all_trials[:,:,1].flatten(),
                   bins=[bins, bins], cmap='inferno')
axs[2].set_title('2D Histogram (0-500 ms, All Trials)')
axs[2].set_xlabel('X Position (degrees)')
axs[2].set_ylabel('Y Position (degrees)')
axs[2].set_aspect('equal')
fig.colorbar(h[3], ax=axs[2], label='Counts')

fig.suptitle(f'{CURRENT_MONKEY.capitalize()} - Sample Eye Position Trials', fontsize=14, y=1.02)
fig.tight_layout()
if SAVE_FIGS:
    fig.savefig(FIGURE_DIR / f'{CURRENT_MONKEY}_sample_eye_position_trials.png', dpi=300)
    fig.savefig(FIGURE_DIR / f'{CURRENT_MONKEY}_sample_eye_position_trials.svg')
plt.show()

#%%
print("""
# =============================================================================
# CONTROL 1: OVERALL EYE POSITION ANALYSIS
# =============================================================================

Test whether systematic differences in mean gaze position between attention conditions
could account for observed neural differences.

HYPOTHESIS: If attention effects are attributable to differences in eye position, then:
1. Attended and unattended trials should have different mean eye positions
2. Neural activity should vary systematically with eye position
3. Attention effects should disappear when controlling for eye position

METHOD:
- Compare mean eye position between attention conditions during stimulus period
- Divide trials into quartiles based on eye position
- Test for attention effects within each position quartile
""")

print("\n2. CONTROL 1: Testing for differences in eye position between attention conditions...")

# Calculate mean and 95% confidence intervals for eye position in each condition
# Note: Using filtered, centered, and smoothed eye position data for this analysis
mean_dpi_attended = np.mean(eye_position[attended_trials_mask], axis=0)
ste_dpi_attended = np.std(eye_position[attended_trials_mask], axis=0) / np.sqrt(len(attended_trial_indices))
mean_dpi_unattended = np.mean(eye_position[unattended_trials_mask], axis=0)
ste_dpi_unattended = np.std(eye_position[unattended_trials_mask], axis=0) / np.sqrt(len(unattended_trial_indices))

# Plot the mean eye position over time for both attention conditions
plt.figure(figsize=(10, 10))

# X-Position Plot
plt.subplot(2, 1, 1)
# Plot 95% confidence interval for unattended trials
plt.fill_between(t_rel_stim,
                 mean_dpi_unattended[:,0] - ste_dpi_unattended[:,0]*1.96,
                 mean_dpi_unattended[:,0] + ste_dpi_unattended[:,0]*1.96,
                 color='b', alpha=0.2, label='Unattended - 95% CI')
plt.plot(t_rel_stim, mean_dpi_unattended[:,0], c='b', label='Unattended - Mean')
# Plot 95% confidence interval for attended trials
plt.fill_between(t_rel_stim,
                 mean_dpi_attended[:,0] - ste_dpi_attended[:,0]*1.96,
                 mean_dpi_attended[:,0] + ste_dpi_attended[:,0]*1.96,
                 color='r', alpha=0.2, label='Attended - 95% CI')
plt.plot(t_rel_stim, mean_dpi_attended[:,0], c='r', label='Attended - Mean')
plt.legend()
plt.title(f'{CURRENT_MONKEY.capitalize()} - {CURRENT_TASK.capitalize()} Task: Eye Position X')
plt.axvline(x=0, color='k', linestyle='--')
plt.ylabel('Horizontal Position (degrees)')
plt.ylim(-15, 15)
plt.grid(True, alpha=0.3)

# Y-Position Plot
plt.subplot(2, 1, 2)
plt.fill_between(t_rel_stim,
                 mean_dpi_unattended[:,1] - ste_dpi_unattended[:,1]*1.96,
                 mean_dpi_unattended[:,1] + ste_dpi_unattended[:,1]*1.96,
                 color='b', alpha=0.2, label='Unattended - 95% CI')
plt.plot(t_rel_stim, mean_dpi_unattended[:,1], c='b', label='Unattended - Mean')
plt.fill_between(t_rel_stim,
                 mean_dpi_attended[:,1] - ste_dpi_attended[:,1]*1.96,
                 mean_dpi_attended[:,1] + ste_dpi_attended[:,1]*1.96,
                 color='r', alpha=0.2, label='Attended - 95% CI')
plt.plot(t_rel_stim, mean_dpi_attended[:,1], c='r', label='Attended - Mean')
# Highlight the analysis window for mean position
plt.fill_betweenx([-15, 15], EYE_POSITION_WINDOW[0], EYE_POSITION_WINDOW[1], color='g', alpha=0.1, label='Position Window', zorder=0)
plt.axvline(x=0, color='k', linestyle='--')
plt.ylim(-15, 15)
plt.legend()
plt.title('Y-Position')
plt.xlabel('Time (s)')
plt.ylabel('Vertical Position (degrees)')
plt.grid(True, alpha=0.3)
plt.tight_layout()
if SAVE_FIGS:
    plt.savefig(FIGURE_DIR / f'{CURRENT_MONKEY}_eye_position_by_attention_condition.png', dpi=300)
    plt.savefig(FIGURE_DIR / f'{CURRENT_MONKEY}_eye_position_by_attention_condition.svg')
plt.show()

print("   - Green shaded region indicates time window for position analysis.")
print("   - X position shows no significant difference between attention conditions.")
print("   - Y position shows a small but consistent difference between conditions.")
print("   - Next, we will test if this small difference can explain the attention effect.")

#%%
# Stratify by eye position to control for the observed difference.
# We will split the distribution of Y eye positions into quartiles and check if the
# attention effect is present within each quartile.

print("\n   Analyzing MUA within eye position quartiles...")
# Define the time mask for calculating mean eye position per trial
pos_mask = (t_rel_stim >= EYE_POSITION_WINDOW[0]) & (t_rel_stim <= EYE_POSITION_WINDOW[1])

# Calculate the mean Y position for each trial within the defined window
trial_pos_y = eye_position[:, pos_mask, 1].mean(axis=1)

# Compare mean positions between conditions
attn_pos_y = trial_pos_y[attended_trials_mask].mean()
unattn_pos_y = trial_pos_y[unattended_trials_mask].mean()
pval = ttest_ind(trial_pos_y[attended_trials_mask], trial_pos_y[unattended_trials_mask]).pvalue
print(f'   - Mean attended Y position: {attn_pos_y:.2f} degrees')
print(f'   - Mean unattended Y position: {unattn_pos_y:.2f} degrees')
print(f'   - T-test for difference in mean Y position: p = {pval:.3f}')

# Define quartile bins based on the overall distribution of eye positions
n_bins = 4
edges = np.percentile(trial_pos_y, np.linspace(0, 100, n_bins + 1))
print(f'   - Y position bin edges (quartiles): {np.round(edges, 2)}')

# Plot the distribution of eye positions for visualization
hist_bins = np.linspace(edges[0], edges[-1], 30)
plt.figure(figsize=(8, 6))
plt.hist(trial_pos_y, bins=hist_bins, label='All trials', color='gray', alpha=0.6)
plt.hist(trial_pos_y[attended_trials_mask], bins=hist_bins, alpha=0.7, label='Attended', color='r')
plt.hist(trial_pos_y[unattended_trials_mask], bins=hist_bins, alpha=0.7, label='Unattended', color='b')

# Add mean indicators and significance connector
plt.scatter([attn_pos_y], [60], color='r', marker='v', s=100, label='Attended Mean', zorder=5)
plt.scatter([unattn_pos_y], [60], color='b', marker='v', s=100, label='Unattended Mean', zorder=5)
significance_connector(attn_pos_y, unattn_pos_y, 65, 5, f'p={pval:.3f}' if pval < 0.05 else 'n.s.')
for e in edges:
    plt.axvline(x=e, color='k', linestyle='--', label='Quartile edges' if e == edges[0] else None, alpha=0.5)
plt.legend()
plt.title('Distribution of Mean Y Eye Position (0.3-0.4s)')
plt.xlabel('Mean Vertical Eye Position (degrees)')
plt.ylabel('Number of Trials')
plt.tight_layout()
if SAVE_FIGS:
    plt.savefig(FIGURE_DIR / f'{CURRENT_MONKEY}_eye_position_distribution.png', dpi=300)
    plt.savefig(FIGURE_DIR / f'{CURRENT_MONKEY}_eye_position_distribution.svg')
plt.show()

print("   - The difference in mean eye position is small compared to the overall distribution.")
print("   - Now, let's see if the MUA attention effect persists within each position quartile.")

#%%
# Plot MUA for attended vs. unattended trials within each eye position quartile
fig, axs = plt.subplots(n_bins+1, 1, figsize=(8, 12), sharex=True, sharey=True)
fig.suptitle(f'{CURRENT_MONKEY.capitalize()} - MUA Conditioned on Eye Position', y=1.02, fontsize=16)

for i in range(n_bins):
    e0, e1 = edges[i], edges[i+1]
    # Create a mask for trials within the current position quartile
    quartile_mask = (trial_pos_y >= e0) & (trial_pos_y <= e1)

    # Calculate MUA for all, attended, and unattended trials in this quartile
    all_activity = population_mua[quartile_mask].mean(axis=0)
    attn_activity = population_mua[quartile_mask & attended_trials_mask]
    unattn_activity = population_mua[quartile_mask & unattended_trials_mask]
    pval = ttest_ind(attn_activity[:, attention_window_mask].mean(axis=1),
                     unattn_activity[:, attention_window_mask].mean(axis=1)).pvalue

    # Plotting
    axs[0].plot(t_rel_stim, all_activity, label=f'Quartile {i+1}: [{e0:.1f}, {e1:.1f}] degrees')
    axs[i+1].plot(t_rel_stim, all_activity, c='gray', alpha=0.5, label='All trials')
    axs[i+1].plot(t_rel_stim, attn_activity.mean(axis=0), label='Attended', color='r')
    axs[i+1].plot(t_rel_stim, unattn_activity.mean(axis=0), label='Unattended', color='b')
    axs[i+1].axvline(x=0, color='k', linestyle='--')
    axs[i+1].set_ylim(-.3, 1.3)
    axs[i+1].axhline(y=0, color='k', linestyle='--', alpha=0.3, zorder=0)
    axs[i+1].set_title(f'Quartile {i+1}: Y Position [{e0:.1f}, {e1:.1f}] degrees - ' + (f'p={pval:.1e}' if pval < 0.05 else 'n.s.'))
    axs[i+1].grid(True, alpha=0.2)
    if i == 0:
        axs[i+1].legend()

axs[0].set_ylabel('Normalized MUA')
axs[0].set_title('All Trials by Eye Position Quartile')
axs[0].legend()
axs[-1].set_xlabel('Time (s)')
fig.text(0.04, 0.5, 'Normalized MUA', va='center', rotation='vertical')
plt.tight_layout(rect=[0.05, 0, 1, 1])
if SAVE_FIGS:
    plt.savefig(FIGURE_DIR / f'{CURRENT_MONKEY}_mua_by_eye_position_quartile.png', dpi=300)
    plt.savefig(FIGURE_DIR / f'{CURRENT_MONKEY}_mua_by_eye_position_quartile.svg')
plt.show()

print("\nCONCLUSION for Control 1:")
print("   - A robust attention effect (Attended > Unattended) is present within each eye position quartile.")
print("   - Therefore, the V1 attention effect is NOT driven by the small systematic difference in mean eye position.")

#%%
print("""
# =============================================================================
# CONTROL 2: MICROSACCADE ANALYSIS
# =============================================================================

Test whether microsaccades during stimulus presentation could confound attention effects.

BACKGROUND:
Microsaccades are small, rapid eye movements (0.1-2Â°) that occur even during fixation.
They can influence neural activity through both feedforward effects on the retinal image and
corollary discharge signals. Previous studies have shown that microsaccade rate and direction
can be modulated by attention, potentially confounding neural attention effects.

HYPOTHESIS: If attention effects are due to microsaccade differences, then including only trials
without microsaccades during stimulus presentation should eliminate the attention effect.

METHOD:
- Detect microsaccades using velocity threshold method
- Identify trials with microsaccades during stimulus period (0-400ms)
- Compare attention effects in trials with vs without microsaccades
""")

print("\n3. CONTROL 2: Microsaccade detection and analysis...")
print("   Using velocity thresholding method for microsaccade detection")
print(f"   - Threshold: {MICROSACCADE_THRESHOLD} degrees/ms")
print(f"   - Minimum intersaccade distance: {MIN_SACCADE_INTERVAL} ms")
print(f"   - Analysis window: {MICROSACCADE_WINDOW[0]}-{MICROSACCADE_WINDOW[1]} s")

# Initialize lists to store detected saccade properties
saccade_trials = []
saccade_samples = []
saccade_times = []

# Optionally create a PDF for manual inspection of detection quality
if EXPORT_SACCADE_PDF:
    pdf_filename = f'{CURRENT_MONKEY}_{CURRENT_TASK}_microsaccades_inspection.pdf'
    print(f"   - Exporting saccade detection plots to: {pdf_filename}")
    pdf = PdfPages(pdf_filename)

try:
    # Loop through each trial to detect microsaccades
    for iT in tqdm(range(total_trials), desc="Detecting microsaccades"):
        # Use scipy's find_peaks on the eye speed signal
        peaks, _ = find_peaks(eye_speed[iT, :], height=MICROSACCADE_THRESHOLD, distance=MIN_SACCADE_INTERVAL)

        # Store results if any peaks are found
        if len(peaks) > 0:
            saccade_samples.append(peaks)
            saccade_trials.append(np.ones(len(peaks)) * iT)
            saccade_times.append(t_rel_stim[peaks])

        # If exporting, create a plot for the current trial and save to PDF
        if EXPORT_SACCADE_PDF:
            fig = plt.figure(figsize=(10, 6))
            # Plot X and Y position
            plt.subplot(2, 1, 1)
            plt.plot(t_rel_stim, eye_position[iT, :, 0], label='X-pos')
            plt.plot(t_rel_stim, eye_position[iT, :, 1], label='Y-pos', color='gray')
            if len(peaks) > 0:
                for p_time in t_rel_stim[peaks]:
                    plt.axvline(x=p_time, color='r', linestyle='--', alpha=0.7)
            plt.title(f'Trial {iT} - Eye Position')
            plt.legend(loc='upper right')
            plt.grid(True, alpha=0.3)
            # Plot eye speed and detected peaks
            plt.subplot(2, 1, 2)
            plt.plot(t_rel_stim, eye_speed[iT, :], label='Speed')
            if len(peaks) > 0:
                plt.plot(t_rel_stim[peaks], eye_speed[iT, peaks], 'rx', label='Detected Saccade')
            plt.axhline(y=MICROSACCADE_THRESHOLD, color='r', linestyle='--', label='Threshold')
            plt.ylim(0, 1)
            plt.title('Eye Speed')
            plt.xlabel('Time (s)')
            plt.legend(loc='upper right')
            plt.grid(True, alpha=0.3)
            plt.tight_layout()
            pdf.savefig(fig)
            plt.close(fig)
finally:
    if EXPORT_SACCADE_PDF:
        pdf.close()

# Concatenate results from all trials into single numpy arrays
saccade_trials = np.concatenate(saccade_trials).astype(int)
saccade_times = np.concatenate(saccade_times)

print(f'   - Detected {len(saccade_times)} microsaccades across {total_trials} trials')

#%%
# Visualize microsaccade timing across all trials
fig, axs = plt.subplots(2, 1, figsize=(8, 8), height_ratios=[2, 1], sharex=True)
fig.suptitle("Microsaccade Timing Across All Trials", fontsize=16)

# Raster plot of microsaccade times for each trial
axs[0].eventplot([saccade_times[saccade_trials==iT] for iT in range(total_trials)], linelengths=5, linewidths=2, colors='k')
axs[0].axvline(x=0, color='r', linestyle='--', alpha=0.7)
axs[0].set_xlim(t_rel_stim[0], t_rel_stim[-1])
axs[0].set_ylim(0, total_trials)
axs[0].set_ylabel('Trial')
axs[0].set_title('Microsaccade Raster Plot')
axs[0].grid(True, axis='x', alpha=0.3)

# Histogram of microsaccade times
axs[1].hist(saccade_times, bins=np.linspace(t_rel_stim[0], t_rel_stim[-1], 70), color='k')
axs[1].axvline(x=0, color='r', linestyle='--', alpha=0.7, label='Stimulus Onset')
axs[1].annotate('Pre-stimulus\nmicrosaccades', xy=(-.1, 20), xytext=(-.05, 40),
             arrowprops=dict(facecolor='black', arrowstyle='->'),
             horizontalalignment='center')
axs[1].annotate('Post-stimulus\nsuppression', xy=(0.1, 5), xytext=(0.15, 30),
             arrowprops=dict(facecolor='black', arrowstyle='->'),
             horizontalalignment='center')
axs[1].annotate('Choice saccades', xy=(.45, 9), xytext=(.35, 40),
             arrowprops=dict(facecolor='black', arrowstyle='->'),
             horizontalalignment='center')
axs[1].set_xlabel('Time (s)')
axs[1].set_ylabel('Number of Saccades')
axs[1].set_title('Microsaccade Rate Histogram')
axs[1].legend()
plt.tight_layout(rect=[0, 0, 1, 0.96])
if SAVE_FIGS:
    plt.savefig(FIGURE_DIR / f'{CURRENT_MONKEY}_microsaccade_timing.png', dpi=300)
    plt.savefig(FIGURE_DIR / f'{CURRENT_MONKEY}_microsaccade_timing.svg')
plt.show()

print("   - Note the characteristic suppression of microsaccades shortly after stimulus onset.")
print("   - Since feedforward effects are most critical, we will exclude trials with any microsaccades in the early stimulus window.")

#%%
# Compare attention effect in trials with vs. without microsaccades in the critical window.

# Identify trials that have at least one microsaccade within the specified window
msacc_window_mask = (saccade_times > MICROSACCADE_WINDOW[0]) & (saccade_times < MICROSACCADE_WINDOW[1])
trials_with_msacc = np.unique(saccade_trials[msacc_window_mask])

# Create a boolean mask for all trials
msacc_trials_mask = np.zeros(total_trials, dtype=bool)
msacc_trials_mask[trials_with_msacc] = True
no_msacc_trials_mask = ~msacc_trials_mask

print(f'   - {np.sum(msacc_trials_mask)} trials WITH microsaccades between {MICROSACCADE_WINDOW[0]}-{MICROSACCADE_WINDOW[1]} s')
print(f'   - {np.sum(no_msacc_trials_mask)} trials WITHOUT microsaccades in this window.')

# Calculate MUA for trials without microsaccades, separated by attention
no_saccade_attended_mua = population_mua[no_msacc_trials_mask & attended_trials_mask].mean(axis=0)
no_saccade_unattended_mua = population_mua[no_msacc_trials_mask & unattended_trials_mask].mean(axis=0)

pval = ttest_ind(
    population_mua[no_msacc_trials_mask & attended_trials_mask][:, attention_window_mask].mean(axis=1),
    population_mua[no_msacc_trials_mask & unattended_trials_mask][:, attention_window_mask].mean(axis=1)
).pvalue

print(f'   - Attention effect in no-microsaccade trials: p = {pval:.3e}')

# Calculate MUA for saccade vs. no-saccade trials (collapsed across attention)
saccade_mua = population_mua[msacc_trials_mask].mean(axis=0)
no_saccade_mua = population_mua[no_msacc_trials_mask].mean(axis=0)

# Plotting the results
fig, axs = plt.subplots(1, 2, figsize=(12, 5), sharey=True)
fig.suptitle("Controlling for Microsaccade Effects", fontsize=16)

# Plot 1: Attention effect in trials WITHOUT microsaccades
axs[0].plot(t_rel_stim, no_saccade_unattended_mua, label='Unattended', color='b')
axs[0].plot(t_rel_stim, no_saccade_attended_mua, label='Attended', color='r')
axs[0].axvline(x=0, color='k', linestyle='--')
axs[0].set_title(f'Attention Effect ({np.sum(no_msacc_trials_mask)} Trials WITHOUT Microsaccades)')
axs[0].set_xlabel('Time (s)')
axs[0].set_ylabel('Normalized MUA')
axs[0].legend()
axs[0].grid(True, alpha=0.3)

# Plot 2: MUA difference between saccade and no-saccade trials
axs[1].plot(t_rel_stim, saccade_mua, label='Saccade Trials', color='g')
axs[1].plot(t_rel_stim, no_saccade_mua, label='No Saccade Trials', color='k')
axs[1].axvline(x=0, color='k', linestyle='--')
axs[1].set_title('MUA: Saccade vs. No Saccade Trials')
axs[1].set_xlabel('Time (s)')
axs[1].legend()
axs[1].grid(True, alpha=0.3)
plt.tight_layout(rect=[0, 0, 1, 0.95])
if SAVE_FIGS:
    plt.savefig(FIGURE_DIR / f'{CURRENT_MONKEY}_mua_control_microsaccades.png', dpi=300)
    plt.savefig(FIGURE_DIR / f'{CURRENT_MONKEY}_mua_control_microsaccades.svg')
plt.show()

print("\nCONCLUSION for Control 2:")
print(f"   - A strong attention effect persists in trials completely free of microsaccades during the stimulus period (p={pval:.1e}).")
print("   - Therefore, the V1 attention effect is NOT driven by microsaccadic eye movements.")

#%%
print("""
# =============================================================================
# CONTROL 3: OCULAR DRIFT (PATH LENGTH) ANALYSIS
# =============================================================================

Test whether differences in ocular drift between attention conditions could account
for observed neural differences.

BACKGROUND:
Even during attempted fixation, the eyes exhibit slow drift movements. This drift can:
1. Change the retinal image location continuously
2. Activate different populations of neurons with different receptive fields
3. Create apparent "attention" effects if drift patterns differ between conditions

DRIFT QUANTIFICATION:
Path length = cumulative eye speed during stimulus period. A sensitive measure of ocular instability.

HYPOTHESIS: If attention effects are due to drift differences, then:
1. Attended and unattended trials should have different path lengths
2. Neural activity should vary systematically with path length
3. Attention effects should disappear when controlling for path length
""")

print("\n4. CONTROL 3: Ocular drift (path length) analysis...")
print(f"   - Analysis window: {DRIFT_ANALYSIS_WINDOW[0]}-{DRIFT_ANALYSIS_WINDOW[1]} s")

# Define time mask for drift analysis
drift_mask = (t_rel_stim >= DRIFT_ANALYSIS_WINDOW[0]) & (t_rel_stim <= DRIFT_ANALYSIS_WINDOW[1])

# Calculate path length for each trial by summing speed within the window
trial_path_length = np.sum(eye_speed[:, drift_mask], axis=1)

# Separate path lengths by attention condition
attended_path_length = trial_path_length[attended_trials_mask]
unattended_path_length = trial_path_length[unattended_trials_mask]

# Compare mean path length between conditions
mean_attended_path_length = np.mean(attended_path_length)
mean_unattended_path_length = np.mean(unattended_path_length)
pval = ttest_ind(attended_path_length, unattended_path_length).pvalue
print(f'   - Mean attended path length: {mean_attended_path_length:.2f}')
print(f'   - Mean unattended path length: {mean_unattended_path_length:.2f}')
print(f'   - T-test for difference in path length: p = {pval:.3f}')

# Define quartile bins based on the overall distribution of path lengths
n_bins = 4
edges = np.percentile(trial_path_length, np.linspace(0, 100, n_bins + 1))
print(f'   - Path length bin edges (quartiles): {np.round(edges, 2)}')

# Plot the distribution of path lengths
bins = np.linspace(trial_path_length.min(), trial_path_length.max(), 30)
plt.figure(figsize=(8, 6))
plt.hist(trial_path_length, bins=bins, color='gray', label='All Trials', alpha=0.6)
plt.hist(attended_path_length, bins=bins, alpha=0.7, label='Attended', color='r')
plt.hist(unattended_path_length, bins=bins, alpha=0.7, label='Unattended', color='b')

# Add mean indicators and significance
plt.scatter([mean_attended_path_length], [60], color='r', marker='v', s=100, label='Attended Mean', zorder=5)
plt.scatter([mean_unattended_path_length], [60], color='b', marker='v', s=100, label='Unattended Mean', zorder=5)
significance_connector(mean_attended_path_length, mean_unattended_path_length, 65, 5, 'n.s.' if pval > 0.05 else f'p={pval:.3f}')
for e in edges:
    plt.axvline(x=e, color='k', linestyle='--', label='Quartile edges' if e == edges[0] else None, alpha=0.5)
plt.legend()
plt.title(f'Distribution of Path Lengths ({DRIFT_ANALYSIS_WINDOW[0]}-{DRIFT_ANALYSIS_WINDOW[1]}s)')
plt.xlabel('Path Length (arbitrary units)')
plt.ylabel('Number of Trials')
plt.tight_layout()
if SAVE_FIGS:
    plt.savefig(FIGURE_DIR / f'{CURRENT_MONKEY}_path_length_distribution.png', dpi=300)
    plt.savefig(FIGURE_DIR / f'{CURRENT_MONKEY}_path_length_distribution.svg')
plt.show()

print("   - There is no significant difference in path length between attended and unattended trials.")
print("   - Nevertheless, we will check if the attention effect persists within each path length quartile as a stringent control.")

#%%
# Plot MUA for attended vs. unattended trials within each path length quartile
fig, axs = plt.subplots(n_bins+1, 1, figsize=(8, 12), sharex=True, sharey=True)
fig.suptitle(f'{CURRENT_MONKEY.capitalize()} - MUA Conditioned on Path Length', y=1.02, fontsize=16)

for i in range(n_bins):
    e0, e1 = edges[i], edges[i+1]
    # Create a mask for trials within the current path length quartile
    quartile_mask = (trial_path_length >= e0) & (trial_path_length <= e1)

    # Calculate MUA for all, attended, and unattended trials in this quartile
    all_mua = population_mua[quartile_mask].mean(axis=0)
    attended_mua = population_mua[quartile_mask & attended_trials_mask].mean(axis=0)
    unattended_mua = population_mua[quartile_mask & unattended_trials_mask].mean(axis=0)

    pval = ttest_ind(
        population_mua[quartile_mask & attended_trials_mask][:, attention_window_mask].mean(axis=1),
        population_mua[quartile_mask & unattended_trials_mask][:, attention_window_mask].mean(axis=1)
    ).pvalue

    # Plotting
    axs[0].plot(t_rel_stim, all_mua, label='Quartile ' + str(i+1))
    axs[i+1].plot(t_rel_stim, all_mua, c='gray', alpha=0.5, label='All trials')
    axs[i+1].plot(t_rel_stim, attended_mua, label='Attended', color='r')
    axs[i+1].plot(t_rel_stim, unattended_mua, label='Unattended', color='b')
    axs[i+1].set_title(f'Quartile {i+1}: Path Length [{edges[i]:.2f}, {edges[i+1]:.2f}] - ' + (f'p={pval:.1e}' if pval < 0.05 else 'n.s.'))
    axs[i+1].axvline(x=0, color='k', linestyle='--')
    axs[i+1].grid(True, alpha=0.2)
    axs[i+1].axhline(y=0, color='k', linestyle='--', alpha=0.3, zorder=0)
    if i == 0:
        axs[i+1].legend()

axs[0].set_title('All Trials by Path Length Quartile')
axs[0].legend()
axs[-1].set_xlabel('Time (s)')
fig.text(0.04, 0.5, 'Normalized MUA', va='center', rotation='vertical')
plt.tight_layout(rect=[0.05, 0, 1, 1])
if SAVE_FIGS:
    plt.savefig(FIGURE_DIR / f'{CURRENT_MONKEY}_mua_by_path_length_quartile.png', dpi=300)
    plt.savefig(FIGURE_DIR / f'{CURRENT_MONKEY}_mua_by_path_length_quartile.svg')
plt.show()

print("""
KEY FINDING: Attention effects persist across all path length quartiles.

INTERPRETATION:
- Although there is a slight modulation of MUA by path length (higher drift = slightly higher MUA),
  the attention effect is robustly present in all quartiles.
- This demonstrates that neural attention effects are not mere artifacts of ocular drift.

CONCLUSION for Control 3: The attentional modulation of V1 multi-unit activity is not driven by
differences in ocular drift between attended and unattended conditions.
""")

print("\n" + "="*70)
print("SUMMARY OF EYE MOVEMENT CONTROLS")
print("="*70)
print("The three comprehensive eye movement controls demonstrate that:")
print("1. EYE POSITION CONTROL: Attention effects persist within each eye position quartile.")
print("2. MICROSACCADE CONTROL: Attention effects remain in trials without microsaccades.")
print("3. DRIFT CONTROL: Attention effects are present across all ocular drift levels.")
print()
print("CONCLUSION:")
print("These controls were unable to explain away the V1 attentional affects as being")
print("due to eye movements during fixation.")
print("="*70)
