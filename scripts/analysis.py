"""
Eye Movement Control Analysis for V1 Cognitive Map Study
=========================================================

This script loads preprocessed neural and eye tracking data from HDF5 and runs
three comprehensive eye movement control analyses to demonstrate that attentional
modulation of V1 activity is not driven by eye movements.

ANALYSES:
---------
0. Baseline Attention Effect: Establish the core attention effect
1. Eye Position Control: Tests whether mean gaze position differences explain neural effects
2. Microsaccade Control: Excludes trials with microsaccades during stimulus presentation
3. Drift Control (Path Length): Controls for overall ocular drift

DEPENDENCIES:
-------------
- Requires preprocessed_data.h5 generated by preprocessing.py
- numpy, matplotlib, scipy (signal processing)
- pathlib (file handling)
- tqdm (progress bars)
- Custom utils module (smooth, significance_connector)

Install dependencies using uv:
    uv sync
    uv run python scripts/analysis.py

USAGE:
------
1. First run preprocessing.py to generate preprocessed_data.h5
2. Run this script: python scripts/analysis.py (analyzes both monkeys simultaneously)

OUTPUTS:
--------
- Statistical comparisons of eye movements between attention conditions
- Microsaccade detection and timing visualizations
- Neural activity plots stratified by eye movement controls
- Demonstrates persistence of attention effects after controlling for eye movements

Author: Ryan Ressmeyer
"""

#%%
import numpy as np
import matplotlib
import matplotlib.pyplot as plt
from pathlib import Path
from scipy.signal import find_peaks
from scipy.stats import ttest_ind
from matplotlib.backends.backend_pdf import PdfPages
from tqdm import tqdm
from utils import significance_connector, is_notebook
import h5py
np.random.seed(1001) # For reproducibility

if is_notebook():
    matplotlib.use('inline')
else:
    matplotlib.use('Qt5Agg')

#%%
# =============================================================================
# HELPER FUNCTIONS FOR TWO-MONKEY ANALYSIS
# =============================================================================

def pvalue_to_stars(pval):
    """
    Convert p-value to star notation for significance display.

    Args:
        pval: p-value from statistical test

    Returns:
        str: Star notation (*** for p<0.001, ** for p<0.01, * for p<0.05, n.s. otherwise)
    """
    if pval < 0.001:
        return '***'
    elif pval < 0.01:
        return '**'
    elif pval < 0.05:
        return '*'
    else:
        return 'n.s.'


def add_significance_window(ax, window, pval, y_pos=0.6, bar_height=0.02):
    """
    Add a horizontal bar showing the counting window with significance stars.

    Args:
        ax: matplotlib axis
        window: tuple of (start_time, end_time) for the counting window
        pval: p-value to display
        y_pos: y-position for the bar (default 0.6)
        bar_height: height of the bar in data coordinates
    """
    # Draw horizontal bar for the window
    ax.plot([window[0], window[1]], [y_pos, y_pos], 'k-', linewidth=3, solid_capstyle='butt')

    # Add vertical caps at the ends
    ax.plot([window[0], window[0]], [y_pos - bar_height/2, y_pos + bar_height/2], 'k-', linewidth=2)
    ax.plot([window[1], window[1]], [y_pos - bar_height/2, y_pos + bar_height/2], 'k-', linewidth=2)

    # Add p-value text with stars above the bar
    stars = pvalue_to_stars(pval)
    window_center = (window[0] + window[1]) / 2
    if stars == 'n.s.':
        text = f'{stars}\n(p={pval:.3f})'
    else:
        text = f'{stars}\n(p={pval:.1e})'
    ax.text(window_center, y_pos + 0.05, text,
            horizontalalignment='center', verticalalignment='bottom',
            fontsize=14)


def analyze_baseline_attention_effect(population_mua, trial_attended, t_rel_stim, attention_window, **kwargs):
    """
    Calculate attention effect statistics for baseline comparison.

    Returns:
        all_mua: mean MUA across all trials
        attended_mua: mean MUA for attended trials
        unattended_mua: mean MUA for unattended trials
        stats: dict with means, difference, and p-value
    """
    all_mua = population_mua.mean(axis=0)
    attended_mua = population_mua[trial_attended == 1].mean(axis=0)
    unattended_mua = population_mua[trial_attended == 0].mean(axis=0)

    # Calculate statistics in attention window
    window_mask = (t_rel_stim >= attention_window[0]) & (t_rel_stim <= attention_window[1])
    attended_window = population_mua[trial_attended == 1][:, window_mask].mean(axis=1)
    unattended_window = population_mua[trial_attended == 0][:, window_mask].mean(axis=1)

    stats = {
        'mean_attended': attended_window.mean(),
        'mean_unattended': unattended_window.mean(),
        'difference': attended_window.mean() - unattended_window.mean(),
        'pvalue': ttest_ind(attended_window, unattended_window).pvalue
    }

    return all_mua, attended_mua, unattended_mua, stats


def calculate_eye_position_stats(eye_position, trial_attended, t_rel_stim, eye_position_window, **kwargs):
    """
    Calculate eye position statistics and quartiles.

    Returns:
        mean_attended: mean eye position over time for attended trials
        ste_attended: standard error for attended trials
        mean_unattended: mean eye position over time for unattended trials
        ste_unattended: standard error for unattended trials
        trial_pos_y: mean Y position per trial in analysis window
        quartile_edges: bin edges for quartile analysis
        pvalue: t-test p-value for Y position difference
    """
    # Calculate mean and STE for each condition
    n_attended = np.sum(trial_attended == 1)
    n_unattended = np.sum(trial_attended == 0)
    mean_attended = eye_position[trial_attended == 1].mean(axis=0)
    ste_attended = eye_position[trial_attended == 1].std(axis=0) / np.sqrt(n_attended)
    mean_unattended = eye_position[trial_attended == 0].mean(axis=0)
    ste_unattended = eye_position[trial_attended == 0].std(axis=0) / np.sqrt(n_unattended)

    # Calculate mean Y position per trial in specified window
    pos_mask = (t_rel_stim >= eye_position_window[0]) & (t_rel_stim <= eye_position_window[1])
    trial_pos_y = eye_position[:, pos_mask, 1].mean(axis=1)

    # Calculate quartile edges
    quartile_edges = np.percentile(trial_pos_y, np.linspace(0, 100, 5))

    # Calculate t-test
    pvalue = ttest_ind(trial_pos_y[trial_attended == 1], trial_pos_y[trial_attended == 0]).pvalue

    return mean_attended, ste_attended, mean_unattended, ste_unattended, trial_pos_y, quartile_edges, pvalue


def detect_microsaccades(eye_speed, t_rel_stim, threshold, min_interval, total_trials, **kwargs):
    """
    Detect microsaccades using velocity threshold method.

    Returns:
        saccade_trials: array of trial indices with detected saccades
        saccade_times: array of saccade times relative to stimulus
        saccade_samples: list of sample indices per trial
    """
    saccade_trials_list = []
    saccade_samples_list = []
    saccade_times_list = []

    for iT in tqdm(range(total_trials), desc="Detecting microsaccades"):
        peaks, _ = find_peaks(eye_speed[iT, :], height=threshold, distance=min_interval)
        peaks = peaks[peaks > 1]  # Exclude any peaks at time 1

        # Always append peaks (even if empty) to maintain trial alignment
        saccade_samples_list.append(peaks)

        # Only append to other lists when microsaccades are actually detected
        if len(peaks) > 0:
            saccade_trials_list.append(np.ones(len(peaks)) * iT)
            saccade_times_list.append(t_rel_stim[peaks])

    # Concatenate results
    saccade_trials = np.concatenate(saccade_trials_list).astype(int) if saccade_trials_list else np.array([])
    saccade_times = np.concatenate(saccade_times_list) if saccade_times_list else np.array([])
    saccade_samples = saccade_samples_list

    return saccade_trials, saccade_times, saccade_samples


def calculate_path_length(eye_speed, trial_attended, t_rel_stim, drift_analysis_window, **kwargs):
    """
    Calculate path length (cumulative eye speed) statistics and quartiles.

    Returns:
        trial_path_length: path length for each trial
        quartile_edges: bin edges for quartile analysis
        mean_attended: mean path length for attended trials
        mean_unattended: mean path length for unattended trials
        pvalue: t-test p-value for path length difference
    """
    # Calculate path length for each trial
    drift_mask = (t_rel_stim >= drift_analysis_window[0]) & (t_rel_stim <= drift_analysis_window[1])
    trial_path_length = np.sum(eye_speed[:, drift_mask], axis=1)

    # Calculate quartile edges
    quartile_edges = np.percentile(trial_path_length, np.linspace(0, 100, 5))

    # Calculate means and t-test
    attended_path_length = trial_path_length[trial_attended == 1]
    unattended_path_length = trial_path_length[trial_attended == 0]
    mean_attended = attended_path_length.mean()
    mean_unattended = unattended_path_length.mean()
    pvalue = ttest_ind(attended_path_length, unattended_path_length).pvalue

    return trial_path_length, quartile_edges, mean_attended, mean_unattended, pvalue


def generate_microsaccade_diagnostic_pdf(pdf_path, eye_position, eye_speed, t_rel_stim,
                                         saccade_samples, threshold, trial_attended):
    """
    Generate a multi-page PDF with trial-by-trial microsaccade detection diagnostics.

    Args:
        pdf_path: Path to save the PDF file
        eye_position: Filtered eye position array [trials x time x 2]
        eye_speed: Eye speed array [trials x time]
        t_rel_stim: Time vector relative to stimulus onset
        saccade_samples: List of arrays containing sample indices of detected saccades per trial
        threshold: Velocity threshold used for detection
        trial_attended: Array indicating attention condition per trial (1=attended, 0=unattended)
    """
    total_trials = eye_position.shape[0]

    with PdfPages(pdf_path) as pdf:
        for iT in tqdm(range(total_trials), desc="Generating PDF"):
            fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(12, 8), sharex=True)

            # Determine attention condition for title
            attn_label = "Attended" if trial_attended[iT] == 1 else "Unattended"
            fig.suptitle(f'Trial {iT+1}/{total_trials} - {attn_label}', fontsize=14, fontweight='bold')

            # Top subplot: Eye position (X and Y)
            # Plot filtered traces
            ax1.plot(t_rel_stim, eye_position[iT, :, 0], 'C0-', label='X Position', linewidth=1.5)
            ax1.plot(t_rel_stim, eye_position[iT, :, 1], 'C1-', label='Y Position', linewidth=1.5)
            ax1.axvline(x=0, color='k', linestyle='--', linewidth=1, alpha=0.5, label='Stimulus Onset')

            # Add vertical lines for detected microsaccades
            if len(saccade_samples[iT]) > 0:
                for saccade_idx in saccade_samples[iT]:
                    ax1.axvline(x=t_rel_stim[saccade_idx], color='g', linestyle='-',
                               linewidth=2, alpha=0.7)

            ax1.set_ylabel('Position (degrees)', fontsize=11)
            ax1.set_title('Eye Position', fontsize=12)
            ax1.legend(loc='upper right', fontsize=9)
            ax1.grid(True, alpha=0.3)
            ax1.set_ylim(-1, 1)

            # Bottom subplot: Eye speed
            ax2.plot(t_rel_stim, eye_speed[iT, :], 'k-', linewidth=1.5, label='Speed')
            ax2.axhline(y=threshold, color='orange', linestyle='--', linewidth=2,
                       label=f'Threshold ({threshold} deg/s)', zorder=5)
            ax2.axvline(x=0, color='k', linestyle='--', linewidth=1, alpha=0.5)

            # Add vertical lines for detected microsaccades
            if len(saccade_samples[iT]) > 0:
                for idx, saccade_idx in enumerate(saccade_samples[iT]):
                    label = 'Detected Saccade' if idx == 0 else None
                    ax2.axvline(x=t_rel_stim[saccade_idx], color='g', linestyle='-',
                               linewidth=2, alpha=0.7, label=label)

            ax2.set_xlabel('Time relative to stimulus (s)', fontsize=11)
            ax2.set_ylabel('Speed (deg/s)', fontsize=11)
            ax2.set_title('Eye Speed', fontsize=12)
            ax2.legend(loc='upper right', fontsize=9)
            ax2.grid(True, alpha=0.3)

            # Set consistent y-axis limits for speed
            ax2.set_ylim(0, threshold * 4)

            plt.tight_layout()
            pdf.savefig(fig, dpi=150)
            plt.close(fig)

#%%
# =============================================================================
# CONFIGURATION SECTION
# =============================================================================
# **IMPORTANT**: Update this path to your preprocessed data file
DATAGEN_DIR = '/home/ryanress/code/gac-2024-v1-cognitive-map/data/'
PREPROCESSED_DATA_FILE = Path(DATAGEN_DIR) / 'preprocessed_data.h5'

# Analysis parameters
MONKEYS = ['monkeyF', 'monkeyN']
CURRENT_TASK = 'lums'

# Microsaccade detection parameters
MICROSACCADE_THRESHOLD = {
    'monkeyN': 13,  # Velocity threshold (deg/s)
    'monkeyF': 10   # Velocity threshold (deg/s)
}
MIN_SACCADE_INTERVAL = 100  # Minimum time between saccades (ms at 1kHz = samples)
EXPORT_SACCADE_PDF = False  # Export PDF with microsaccade detection for inspection

# Analysis time windows
ATTENTION_WINDOW = [0.15, 0.5]
MICROSACCADE_WINDOW = [-.025, 0.5]  # Time window for microsaccade exclusion (s)
MICROSACCADE_EFFECT_WINDOW = [0.075, 0.2]  # Time window for testing microsaccade effect on MUA (s)
DRIFT_ANALYSIS_WINDOW = [0, 0.3]  # Time window for path length analysis (s)
EYE_POSITION_WINDOW = [0.25, 0.4]  # Time window for mean position analysis (s)

# Figure output
SAVE_FIGS = True
if SAVE_FIGS:
    FIGURE_DIR = Path('./figures/analysis')
    FIGURE_DIR.mkdir(exist_ok=True, parents=True)

#%%
# =============================================================================
# LOAD PREPROCESSED DATA FROM HDF5
# =============================================================================

print("="*70)
print("EYE MOVEMENT CONTROL ANALYSIS - TWO-MONKEY COMPARISON")
print("="*70)
print(f"Loading preprocessed data from: {PREPROCESSED_DATA_FILE}")
print(f"Analyzing monkeys: {', '.join(MONKEYS)}")
print(f"Task: {CURRENT_TASK}")
print("="*70)

# Load data for both monkeys from HDF5
monkey_data = {}

with h5py.File(PREPROCESSED_DATA_FILE, 'r') as f:
    for monkey in MONKEYS:
        monkey_group = f[monkey]

        # Load arrays for this monkey
        monkey_data[monkey] = {
            'population_mua': monkey_group['population_mua'][:],
            'eye_position': monkey_group['eye_position_filtered'][:],
            'eye_velocity': monkey_group['eye_velocity'][:],
            'eye_speed': monkey_group['eye_speed'][:],
            't_rel_stim': monkey_group['t_rel_stim'][:],
            'trial_attended': monkey_group['trial_attended'][:]
        }

# Print summary statistics for both monkeys
print("\nData Summary:")
for monkey in MONKEYS:
    data = monkey_data[monkey]
    total_trials = data['population_mua'].shape[0]
    n_attended = np.sum(data['trial_attended'] == 1)
    n_unattended = np.sum(data['trial_attended'] == 0)

    print(f"\n{monkey}:")
    print(f"   - Total trials: {total_trials}")
    print(f"   - Attended trials: {n_attended}")
    print(f"   - Unattended trials: {n_unattended}")
    print(f"   - Population MUA shape: {data['population_mua'].shape}")
    print(f"   - Eye data shape: {data['eye_position'].shape}")

#%%
# =============================================================================
# BASELINE NEURAL ATTENTION EFFECT
# =============================================================================
print("""
This section establishes the core attention effect that we will control for.

ANALYSIS: Compare average neural activity between attended and unattended trials
- This is the primary effect we want to show persists after eye movement controls
- Provides the baseline against which we will compare controlled analyses
""")

print("\n1. Analyzing baseline attention effect on neural activity...")

# Analyze both monkeys
results = {}
for monkey in MONKEYS:
    all_mua, att_mua, unatt_mua, stats = analyze_baseline_attention_effect(
        **monkey_data[monkey],
        attention_window=ATTENTION_WINDOW
    )
    results[monkey] = {
        'all_mua': all_mua,
        'attended_mua': att_mua,
        'unattended_mua': unatt_mua,
        'stats': stats
    }

    n_attended = np.sum(monkey_data[monkey]['trial_attended'] == 1)
    n_unattended = np.sum(monkey_data[monkey]['trial_attended'] == 0)

    print(f"\n{monkey}:")
    print(f"   - Attended trials: {n_attended}")
    print(f"   - Unattended trials: {n_unattended}")
    print(f"   - Mean attended activity: {stats['mean_attended']:.3f}")
    print(f"   - Mean unattended activity: {stats['mean_unattended']:.3f}")
    print(f"   - Attention effect magnitude: {stats['difference']:.3f}")
    print(f"   - p-value (t-test): {stats['pvalue']:.3e}")

# Create side-by-side plots (MonkeyN left, MonkeyF right)
fig, axes = plt.subplots(1, 2, figsize=(14, 5), sharey=True)

for idx, monkey in enumerate(['monkeyN', 'monkeyF']):
    ax = axes[idx]
    t_rel_stim = monkey_data[monkey]['t_rel_stim']

    ax.plot(t_rel_stim, results[monkey]['all_mua'], color='gray', label='All Trials', alpha=0.7)
    ax.plot(t_rel_stim, results[monkey]['unattended_mua'], color='b', linewidth=2, label='Unattended')
    ax.plot(t_rel_stim, results[monkey]['attended_mua'], color='r', linewidth=2, label='Attended')
    ax.axvline(x=0, color='k', linestyle='--', linewidth=1)

    # Add counting window with significance
    add_significance_window(ax, ATTENTION_WINDOW, results[monkey]['stats']['pvalue'])

    ax.grid()
    ax.set_xlabel('Time (s)')
    ax.set_ylabel('Normalized MUA')
    ax.legend()
    ax.set_title(f'{monkey.capitalize()} - Baseline Attention Effect')

plt.tight_layout()
if SAVE_FIGS:
    plt.savefig(FIGURE_DIR / 'baseline_attention_effect.png', dpi=300)
    plt.savefig(FIGURE_DIR / 'baseline_attention_effect.svg')
plt.show()

#%%
# =============================================================================
# Visualize Sample Eye Position Trials
# =============================================================================

print("\n   Visualizing sample eye position trials...")

n_trials_to_plot = 3
bins = np.linspace(-.75, .75, 50)  # Position bins in degrees

# Create 2x3 subplot (MonkeyN on top, MonkeyF on bottom)
fig, axs = plt.subplots(2, 3, figsize=(15, 8), width_ratios=[1,1,.8])

for row_idx, monkey in enumerate(['monkeyN', 'monkeyF']):
    data = monkey_data[monkey]
    t_rel_stim = data['t_rel_stim']
    eye_position = data['eye_position']
    trial_attended = data['trial_attended']

    # Select random trials to plot
    attended_indices = np.where(trial_attended == 1)[0]
    unattended_indices = np.where(trial_attended == 0)[0]
    attn_plot = np.random.permutation(attended_indices)[:n_trials_to_plot]
    unattn_plot = np.random.permutation(unattended_indices)[:n_trials_to_plot]
    t_mask = (0 < t_rel_stim) & (t_rel_stim < 0.5)

    ep_unattn = eye_position[unattn_plot]
    ep_attn = eye_position[attn_plot]

    # Panel 1: X Position
    axs[row_idx, 0].plot(t_rel_stim, ep_unattn[:,:,0].T, alpha=1, c='b', linewidth=1)
    axs[row_idx, 0].plot(t_rel_stim, ep_attn[:,:,0].T, alpha=1, c='r', linewidth=1)
    axs[row_idx, 0].axvline(x=0, color='k', linestyle='--', linewidth=1.5)
    axs[row_idx, 0].set_title(f'{monkey.capitalize()} - X Position')
    axs[row_idx, 0].set_ylabel('Position (degrees)')
    axs[row_idx, 0].set_xlabel('Time (s)')
    axs[row_idx, 0].set_ylim(-.75, .75)
    axs[row_idx, 0].grid(True, alpha=0.3)
    if row_idx == 0:  # Add legend only to top row
        lines = [
            matplotlib.lines.Line2D([0], [0], color='b', lw=2, alpha=0.7),
            matplotlib.lines.Line2D([0], [0], color='r', lw=2, alpha=0.7),
            matplotlib.lines.Line2D([0], [0], color='k', lw=1.5, linestyle='--')
        ]
        axs[row_idx, 0].legend(lines, ['Unattended', 'Attended', 'Stimulus Onset'])

    # Panel 2: Y Position
    axs[row_idx, 1].plot(t_rel_stim, ep_unattn[:,:,1].T, alpha=1, c='b', linewidth=1)
    axs[row_idx, 1].plot(t_rel_stim, ep_attn[:,:,1].T, alpha=1, c='r', linewidth=1)
    axs[row_idx, 1].axvline(x=0, color='k', linestyle='--', linewidth=1.5)
    axs[row_idx, 1].set_title(f'{monkey.capitalize()} - Y Position')
    axs[row_idx, 1].set_ylabel('Position (degrees)')
    axs[row_idx, 1].set_xlabel('Time (s)')
    axs[row_idx, 1].set_ylim(-.75, .75)
    axs[row_idx, 1].grid(True, alpha=0.3)

    # Panel 3: 2D Histogram of all trials (0-500ms window)
    ep_all_trials = eye_position[:, t_mask, :]
    h = axs[row_idx, 2].hist2d(ep_all_trials[:,:,0].flatten(),
                       ep_all_trials[:,:,1].flatten(),
                       bins=[bins, bins], cmap='inferno')
    axs[row_idx, 2].set_title(f'{monkey.capitalize()} - 2D Histogram (0-500 ms)')
    axs[row_idx, 2].set_xlabel('X Position (degrees)')
    axs[row_idx, 2].set_ylabel('Y Position (degrees)')
    axs[row_idx, 2].set_aspect('equal')
    fig.colorbar(h[3], ax=axs[row_idx, 2], label='Counts')

fig.suptitle('Sample Eye Position Trials', fontsize=16, y=0.995)
fig.tight_layout()
if SAVE_FIGS:
    fig.savefig(FIGURE_DIR / 'sample_eye_position_trials.png', dpi=300)
    fig.savefig(FIGURE_DIR / 'sample_eye_position_trials.svg')
plt.show()

#%%
print("""
# =============================================================================
# CONTROL 1: MICROSACCADE ANALYSIS
# =============================================================================

Test whether microsaccades during stimulus presentation could confound attention effects.

BACKGROUND:
Microsaccades are small, rapid eye movements (0.1-2°) that occur even during fixation.
They can influence neural activity through both feedforward effects on the retinal image and
corollary discharge signals. Previous studies have shown that microsaccade rate and direction
can be modulated by attention, potentially confounding neural attention effects.

HYPOTHESIS: If attention effects are due to microsaccade differences, then including only trials
without microsaccades during stimulus presentation should eliminate the attention effect.

METHOD:
- Detect microsaccades using velocity threshold method
- Identify trials with microsaccades during stimulus period (0-400ms)
- Compare attention effects in trials with vs without microsaccades
""")

print("\n1. CONTROL 1: Microsaccade detection and analysis...")
print("   Using velocity thresholding method for microsaccade detection")
print(f"   - Threshold: MonkeyN={MICROSACCADE_THRESHOLD['monkeyN']} deg/s, MonkeyF={MICROSACCADE_THRESHOLD['monkeyF']} deg/s")
print(f"   - Minimum intersaccade distance: {MIN_SACCADE_INTERVAL} ms")
print(f"   - Analysis window: {MICROSACCADE_WINDOW[0]}-{MICROSACCADE_WINDOW[1]} s")

# Detect microsaccades for both monkeys
microsaccade_data = {}
for monkey in MONKEYS:
    data = monkey_data[monkey]
    total_trials = data['population_mua'].shape[0]

    saccade_trials, saccade_times, saccade_samples = detect_microsaccades(
        eye_speed=data['eye_speed'],
        t_rel_stim=data['t_rel_stim'],
        threshold=MICROSACCADE_THRESHOLD[monkey],
        min_interval=MIN_SACCADE_INTERVAL,
        total_trials=total_trials
    )

    microsaccade_data[monkey] = {
        'saccade_trials': saccade_trials,
        'saccade_times': saccade_times,
        'saccade_samples': saccade_samples,
        'total_trials': total_trials
    }

    print(f'\n{monkey}:')
    print(f'   - Detected {len(saccade_times)} microsaccades across {total_trials} trials')

# Generate diagnostic PDF if requested
if EXPORT_SACCADE_PDF:
    print("\n   Generating diagnostic PDFs for microsaccade detection...")
    for monkey in MONKEYS:
        pdf_path = FIGURE_DIR / f'microsaccade_diagnostics_{monkey}.pdf'
        generate_microsaccade_diagnostic_pdf(
            pdf_path=pdf_path,
            eye_position=monkey_data[monkey]['eye_position'],
            eye_speed=monkey_data[monkey]['eye_speed'],
            t_rel_stim=monkey_data[monkey]['t_rel_stim'],
            saccade_samples=microsaccade_data[monkey]['saccade_samples'],
            threshold=MICROSACCADE_THRESHOLD[monkey],
            trial_attended=monkey_data[monkey]['trial_attended']
        )
        print(f'   - Saved {pdf_path}')

#%%
# Visualize microsaccade timing across all trials
# Layout: 2 rows × 2 columns (MonkeyN left, MonkeyF right)
fig, axs = plt.subplots(2, 2, figsize=(14, 8), sharex=True)
fig.suptitle("Microsaccade Timing Across All Trials", fontsize=16, y=0.995)

for col_idx, monkey in enumerate(['monkeyN', 'monkeyF']):
    msacc_data = microsaccade_data[monkey]
    saccade_trials = msacc_data['saccade_trials']
    saccade_times = msacc_data['saccade_times']
    total_trials = msacc_data['total_trials']
    t_rel_stim = monkey_data[monkey]['t_rel_stim']

    # Raster plot of microsaccade times for each trial
    if len(saccade_times) > 0:
        axs[0, col_idx].eventplot([saccade_times[saccade_trials==iT] for iT in range(total_trials)],
                                   linelengths=5, linewidths=2, colors='k')
    axs[0, col_idx].axvline(x=0, color='r', linestyle='--', alpha=0.7)
    axs[0, col_idx].set_xlim(t_rel_stim[0], t_rel_stim[-1])
    axs[0, col_idx].set_ylim(0, total_trials)
    axs[0, col_idx].set_ylabel('Trial')
    axs[0, col_idx].set_title(f'{monkey.capitalize()} - Raster Plot')
    axs[0, col_idx].grid(True, axis='x', alpha=0.3)

    # Histogram of microsaccade times
    if len(saccade_times) > 0:
        axs[1, col_idx].hist(saccade_times, bins=np.linspace(t_rel_stim[0], t_rel_stim[-1], 70), color='k')
    axs[1, col_idx].axvline(x=0, color='r', linestyle='--', alpha=0.7, label='Stimulus Onset')

    # Add microsaccade exclusion window (shown in green)
    axs[1, col_idx].axvspan(MICROSACCADE_WINDOW[0], MICROSACCADE_WINDOW[1],
                            alpha=0.2, color='green', zorder=0)

    # Add text label for exclusion window (only on right column to avoid clutter)
    if col_idx == 1:
        window_center = (MICROSACCADE_WINDOW[0] + MICROSACCADE_WINDOW[1]) / 2
        axs[1, col_idx].text(window_center, 30, f'Saccade\nExclusion Window\n({MICROSACCADE_WINDOW[0]} - {MICROSACCADE_WINDOW[1]} s)',
                            horizontalalignment='center', verticalalignment='bottom',
                            fontsize=10, fontweight='bold')

    # Add annotations only to the left column to avoid clutter
    if col_idx == 0:
        axs[1, col_idx].annotate('Pre-stimulus\nmicrosaccades', xy=(-.1, 20), 
                 xytext=(-.075, 40),
                 arrowprops=dict(facecolor='black', arrowstyle='->'),
                 horizontalalignment='center')
        axs[1, col_idx].annotate('Post-stimulus\nsuppression', xy=(0.1, 5), xytext=(0.15, 30),
                 arrowprops=dict(facecolor='black', arrowstyle='->'),
                 horizontalalignment='center')
        axs[1, col_idx].annotate('Choice saccades', xy=(.45, 9), xytext=(.35, 40),
                 arrowprops=dict(facecolor='black', arrowstyle='->'),
                 horizontalalignment='center')

    axs[1, col_idx].set_xlabel('Time (s)')
    axs[1, col_idx].set_ylabel('Number of Saccades')
    axs[1, col_idx].set_title(f'{monkey.capitalize()} - Rate Histogram')
    axs[1, col_idx].legend()

plt.tight_layout(rect=[0, 0, 1, 0.99])
if SAVE_FIGS:
    plt.savefig(FIGURE_DIR / 'microsaccade_timing.png', dpi=300)
    plt.savefig(FIGURE_DIR / 'microsaccade_timing.svg')
plt.show()

print("   - Note the characteristic suppression of microsaccades shortly after stimulus onset.")
print("   - Since feedforward effects are most critical, we will exclude trials with any microsaccades in the early stimulus window.")

#%%
# Compare attention effect in trials with vs. without microsaccades in the critical window.

# Calculate microsaccade trial masks and MUA for both monkeys
msacc_control_results = {}

for monkey in MONKEYS:
    msacc_data = microsaccade_data[monkey]
    data = monkey_data[monkey]
    saccade_trials = msacc_data['saccade_trials']
    saccade_times = msacc_data['saccade_times']
    total_trials = msacc_data['total_trials']
    population_mua = data['population_mua']
    trial_attended = data['trial_attended']
    t_rel_stim = data['t_rel_stim']

    # Identify trials that have at least one microsaccade within the specified window
    if len(saccade_times) > 0:
        msacc_window_mask = (saccade_times > MICROSACCADE_WINDOW[0]) & (saccade_times < MICROSACCADE_WINDOW[1])
        trials_with_msacc = np.unique(saccade_trials[msacc_window_mask])
    else:
        trials_with_msacc = np.array([])

    # Create a boolean mask for all trials
    msacc_trials_mask = np.zeros(total_trials, dtype=bool)
    if len(trials_with_msacc) > 0:
        msacc_trials_mask[trials_with_msacc] = True
    no_msacc_trials_mask = ~msacc_trials_mask

    print(f'\n{monkey}:')
    print(f'   - {np.sum(msacc_trials_mask)} trials WITH microsaccades between {MICROSACCADE_WINDOW[0]}-{MICROSACCADE_WINDOW[1]} s')
    print(f'   - {np.sum(no_msacc_trials_mask)} trials WITHOUT microsaccades in this window.')

    # Calculate MUA for trials without microsaccades
    no_saccade_all_mua = population_mua[no_msacc_trials_mask].mean(axis=0)
    no_saccade_attended_mua = population_mua[no_msacc_trials_mask & (trial_attended == 1)].mean(axis=0)
    no_saccade_unattended_mua = population_mua[no_msacc_trials_mask & (trial_attended == 0)].mean(axis=0)

    # Calculate attention window mask
    attention_window_mask = (t_rel_stim >= ATTENTION_WINDOW[0]) & (t_rel_stim <= ATTENTION_WINDOW[1])

    pval = ttest_ind(
        population_mua[no_msacc_trials_mask & (trial_attended == 1)][:, attention_window_mask].mean(axis=1),
        population_mua[no_msacc_trials_mask & (trial_attended == 0)][:, attention_window_mask].mean(axis=1)
    ).pvalue

    print(f'   - Attention effect in no-microsaccade trials: p = {pval:.3e}')

    # Calculate MUA for saccade vs. no-saccade trials (collapsed across attention)
    saccade_mua = population_mua[msacc_trials_mask].mean(axis=0) if np.sum(msacc_trials_mask) > 0 else np.zeros_like(t_rel_stim)
    no_saccade_mua = population_mua[no_msacc_trials_mask].mean(axis=0)

    # Calculate significance between saccade and no-saccade trials in microsaccade effect window
    microsaccade_effect_window_mask = (t_rel_stim >= MICROSACCADE_EFFECT_WINDOW[0]) & (t_rel_stim <= MICROSACCADE_EFFECT_WINDOW[1])
    if np.sum(msacc_trials_mask) > 0:
        pval_saccade_effect = ttest_ind(
            population_mua[msacc_trials_mask][:, microsaccade_effect_window_mask].mean(axis=1),
            population_mua[no_msacc_trials_mask][:, microsaccade_effect_window_mask].mean(axis=1)
        ).pvalue
    else:
        pval_saccade_effect = 1.0

    msacc_control_results[monkey] = {
        'no_saccade_all_mua': no_saccade_all_mua,
        'no_saccade_attended_mua': no_saccade_attended_mua,
        'no_saccade_unattended_mua': no_saccade_unattended_mua,
        'saccade_mua': saccade_mua,
        'no_saccade_mua': no_saccade_mua,
        'pval': pval,
        'pval_saccade_effect': pval_saccade_effect,
        'n_no_msacc': np.sum(no_msacc_trials_mask)
    }

# Plotting the results (2 rows × 2 columns)
# Row 0: Attention effect in no-saccade trials (MonkeyN left, MonkeyF right)
# Row 1: Saccade vs no-saccade comparison (MonkeyN left, MonkeyF right)
fig, axs = plt.subplots(2, 2, figsize=(14, 10), sharey='row')
fig.suptitle("Controlling for Microsaccade Effects", fontsize=16, y=0.995)

for col_idx, monkey in enumerate(['monkeyN', 'monkeyF']):
    results = msacc_control_results[monkey]
    t_rel_stim = monkey_data[monkey]['t_rel_stim']

    # Row 0: Attention effect in trials WITHOUT microsaccades
    axs[0, col_idx].plot(t_rel_stim, results['no_saccade_all_mua'], color='gray',
                         label='All Trials (No Msacc)', linestyle='--', alpha=0.7)
    axs[0, col_idx].plot(t_rel_stim, results['no_saccade_unattended_mua'], label='Unattended', color='b', linewidth=2)
    axs[0, col_idx].plot(t_rel_stim, results['no_saccade_attended_mua'], label='Attended', color='r', linewidth=2)
    axs[0, col_idx].axvline(x=0, color='k', linestyle='--')

    # Add counting window with significance
    add_significance_window(axs[0, col_idx], ATTENTION_WINDOW, results['pval'])

    axs[0, col_idx].set_title(f'{monkey.capitalize()} - Trials Without Microsaccades (N={results["n_no_msacc"]})')
    axs[0, col_idx].set_xlabel('Time (s)')
    axs[0, col_idx].set_ylabel('Normalized MUA')
    axs[0, col_idx].legend()
    axs[0, col_idx].grid(True, alpha=0.3)

    # Row 1: MUA difference between saccade and no-saccade trials
    axs[1, col_idx].plot(t_rel_stim, results['saccade_mua'], label='Saccade Trials', color='g', linewidth=2)
    axs[1, col_idx].plot(t_rel_stim, results['no_saccade_mua'], label='No Saccade Trials', color='k', linewidth=2)
    axs[1, col_idx].axvline(x=0, color='k', linestyle='--')

    # Add significance window for saccade effect
    add_significance_window(axs[1, col_idx], MICROSACCADE_EFFECT_WINDOW, results['pval_saccade_effect'],
                           y_pos=0.5, bar_height=0.02)

    axs[1, col_idx].set_title(f'{monkey.capitalize()} - Effect of Microsaccades on MUA')
    axs[1, col_idx].set_xlabel('Time (s)')
    axs[1, col_idx].set_ylabel('Normalized MUA')
    axs[1, col_idx].legend()
    axs[1, col_idx].grid(True, alpha=0.3)

plt.tight_layout(rect=[0, 0, 1, 0.99])
if SAVE_FIGS:
    plt.savefig(FIGURE_DIR / 'mua_control_microsaccades.png', dpi=300)
    plt.savefig(FIGURE_DIR / 'mua_control_microsaccades.svg')
plt.show()

print("\nCONCLUSION for Control 1:")
print("   - A strong attention effect persists in trials completely free of microsaccades during the stimulus period.")
print("   - Therefore, the V1 attention effect is NOT driven by microsaccadic eye movements.")

#%%
# ADD EXAMPLE OF EYE POSITION DEPENDENT CONTROL


#%%
print("""
# =============================================================================
# CONTROL 2: OVERALL EYE POSITION ANALYSIS
# =============================================================================

Test whether systematic differences in mean gaze position between attention conditions
could account for observed neural differences.

HYPOTHESIS: If attention effects are attributable to differences in eye position, then:
1. Attended and unattended trials should have different mean eye positions
2. Neural activity should vary systematically with eye position
3. Attention effects should disappear when controlling for eye position

METHOD:
- Compare mean eye position between attention conditions during stimulus period
- Divide trials into quartiles based on eye position
- Test for attention effects within each position quartile
""")

print("\n2. CONTROL 2: Testing for differences in eye position between attention conditions...")

# Calculate statistics for both monkeys
eye_pos_stats = {}
for monkey in MONKEYS:
    mean_att, ste_att, mean_unatt, ste_unatt, _, _, _ = calculate_eye_position_stats(
        **monkey_data[monkey],
        eye_position_window=EYE_POSITION_WINDOW
    )
    eye_pos_stats[monkey] = {
        'mean_attended': mean_att,
        'ste_attended': ste_att,
        'mean_unattended': mean_unatt,
        'ste_unattended': ste_unatt
    }

# Plot the mean eye position over time for both monkeys (2 rows × 2 columns)
# MonkeyN on left, MonkeyF on right
fig, axes = plt.subplots(2, 2, figsize=(14, 10), sharex=True)

for col_idx, monkey in enumerate(['monkeyN', 'monkeyF']):
    t_rel_stim = monkey_data[monkey]['t_rel_stim']
    stats = eye_pos_stats[monkey]
    mean_att = stats['mean_attended']
    ste_att = stats['ste_attended']
    mean_unatt = stats['mean_unattended']
    ste_unatt = stats['ste_unattended']

    # X-Position Plot (top row)
    ax = axes[0, col_idx]
    ax.fill_between(t_rel_stim,
                    mean_unatt[:,0] - ste_unatt[:,0]*1.96,
                    mean_unatt[:,0] + ste_unatt[:,0]*1.96,
                    color='b', alpha=0.2, label='Unattended - 95% CI')
    ax.plot(t_rel_stim, mean_unatt[:,0], c='b', label='Unattended')
    ax.fill_between(t_rel_stim,
                    mean_att[:,0] - ste_att[:,0]*1.96,
                    mean_att[:,0] + ste_att[:,0]*1.96,
                    color='r', alpha=0.2, label='Attended - 95% CI')
    ax.plot(t_rel_stim, mean_att[:,0], c='r', label='Attended')
    ax.axvline(x=0, color='k', linestyle='--')
    ax.set_ylabel('Horizontal Position (degrees)')
    ax.set_ylim(-.2, .2)
    ax.set_title(f'{monkey.capitalize()} - X Position')
    ax.grid(True, alpha=0.3)
    ax.legend()

    # Y-Position Plot (bottom row)
    ax = axes[1, col_idx]
    ax.fill_between(t_rel_stim,
                    mean_unatt[:,1] - ste_unatt[:,1]*1.96,
                    mean_unatt[:,1] + ste_unatt[:,1]*1.96,
                    color='b', alpha=0.2, label='Unattended - 95% CI')
    ax.plot(t_rel_stim, mean_unatt[:,1], c='b', label='Unattended')
    ax.fill_between(t_rel_stim,
                    mean_att[:,1] - ste_att[:,1]*1.96,
                    mean_att[:,1] + ste_att[:,1]*1.96,
                    color='r', alpha=0.2, label='Attended - 95% CI')
    ax.plot(t_rel_stim, mean_att[:,1], c='r', label='Attended')
    # Highlight the analysis window for mean position
    ax.fill_betweenx([-15, 15], EYE_POSITION_WINDOW[0], EYE_POSITION_WINDOW[1],
                     color='g', alpha=0.1, label='Position Window', zorder=0)
    ax.axvline(x=0, color='k', linestyle='--')
    ax.set_ylim(-.2, .2)
    ax.set_xlabel('Time (s)')
    ax.set_ylabel('Vertical Position (degrees)')
    ax.set_title(f'{monkey.capitalize()} - Y Position')
    ax.grid(True, alpha=0.3)
    ax.legend()

fig.suptitle('Eye Position by Attention Condition', fontsize=16, y=0.995)
plt.tight_layout()
if SAVE_FIGS:
    plt.savefig(FIGURE_DIR / 'eye_position_by_attention_condition.png', dpi=300)
    plt.savefig(FIGURE_DIR / 'eye_position_by_attention_condition.svg')
plt.show()

print("   - Green shaded region indicates time window for position analysis.")
print("   - X position shows no significant difference between attention conditions.")
print("   - Y position shows a small but consistent difference between conditions.")
print("   - Next, we will test if this small difference can explain the attention effect.")

#%%
# Stratify by eye position to control for the observed difference.
# We will split the distribution of Y eye positions into quartiles and check if the
# attention effect is present within each quartile.

print("\n   Analyzing MUA within eye position quartiles...")

# Calculate position statistics for both monkeys
n_bins = 4
position_data = {}

for monkey in MONKEYS:
    _, _, _, _, trial_pos_y, edges, pval = calculate_eye_position_stats(
        **monkey_data[monkey],
        eye_position_window=EYE_POSITION_WINDOW
    )
    trial_attended = monkey_data[monkey]['trial_attended']

    attn_pos_y = trial_pos_y[trial_attended == 1].mean()
    unattn_pos_y = trial_pos_y[trial_attended == 0].mean()

    position_data[monkey] = {
        'trial_pos_y': trial_pos_y,
        'edges': edges,
        'pval': pval,
        'attn_pos_y': attn_pos_y,
        'unattn_pos_y': unattn_pos_y
    }

    print(f'\n{monkey}:')
    print(f'   - Mean attended Y position: {attn_pos_y:.2f} degrees')
    print(f'   - Mean unattended Y position: {unattn_pos_y:.2f} degrees')
    print(f'   - T-test for difference in mean Y position: p = {pval:.3f}')
    print(f'   - Y position bin edges (quartiles): {np.round(edges, 2)}')

# Plot the distribution of eye positions for both monkeys (side-by-side)
fig, axes = plt.subplots(1, 2, figsize=(14, 6))

for col_idx, monkey in enumerate(['monkeyN', 'monkeyF']):
    ax = axes[col_idx]
    data = position_data[monkey]
    trial_pos_y = data['trial_pos_y']
    edges = data['edges']
    pval = data['pval']
    attn_pos_y = data['attn_pos_y']
    unattn_pos_y = data['unattn_pos_y']
    trial_attended = monkey_data[monkey]['trial_attended']

    hist_bins = np.linspace(edges[0], edges[-1], 30)
    ax.hist(trial_pos_y, bins=hist_bins, label='All trials', color='gray', alpha=0.6)
    ax.hist(trial_pos_y[trial_attended == 1], bins=hist_bins, alpha=0.7, label='Attended', color='r')
    ax.hist(trial_pos_y[trial_attended == 0], bins=hist_bins, alpha=0.7, label='Unattended', color='b')

    # Add mean indicators and significance connector
    ax.scatter([attn_pos_y], [60], color='r', marker='v', s=100, label='Attended Mean', zorder=5)
    ax.scatter([unattn_pos_y], [60], color='b', marker='v', s=100, label='Unattended Mean', zorder=5)
    pval_text = f'{pvalue_to_stars(pval)}\n(p={pval:.1e})' if pval < 0.05 else 'n.s.'
    significance_connector(attn_pos_y, unattn_pos_y, 65, 5, pval_text, ax=ax)

    for e in edges:
        ax.axvline(x=e, color='k', linestyle='--', label='Quartile edges' if e == edges[0] else None, alpha=0.5)

    ax.legend()
    ax.set_title(f'{monkey.capitalize()} - Mean Y Eye Position (0.3-0.4s)')
    ax.set_xlabel('Mean Vertical Eye Position (degrees)')
    ax.set_ylabel('Number of Trials')

fig.suptitle('Distribution of Eye Position', fontsize=16, y=1.00)
plt.tight_layout()
if SAVE_FIGS:
    plt.savefig(FIGURE_DIR / 'eye_position_distribution.png', dpi=300)
    plt.savefig(FIGURE_DIR / 'eye_position_distribution.svg')
plt.show()

print("\n   - The difference in mean eye position is small compared to the overall distribution.")
print("   - Now, let's see if the MUA attention effect persists within each position quartile.")

#%%
# Plot MUA for attended vs. unattended trials within each eye position quartile
# Layout: 5 rows × 2 columns (MonkeyN left, MonkeyF right)
fig, axs = plt.subplots(n_bins+1, 2, figsize=(14, 12), sharex=True, sharey=True)
fig.suptitle('MUA Conditioned on Eye Position', y=0.995, fontsize=16)

for col_idx, monkey in enumerate(['monkeyN', 'monkeyF']):
    data = monkey_data[monkey]
    pos_data = position_data[monkey]
    population_mua = data['population_mua']
    trial_attended = data['trial_attended']
    t_rel_stim = data['t_rel_stim']
    trial_pos_y = pos_data['trial_pos_y']
    edges = pos_data['edges']

    # Calculate attention window mask
    attention_window_mask = (t_rel_stim >= ATTENTION_WINDOW[0]) & (t_rel_stim <= ATTENTION_WINDOW[1])

    for i in range(n_bins):
        e0, e1 = edges[i], edges[i+1]
        # Create a mask for trials within the current position quartile
        quartile_mask = (trial_pos_y >= e0) & (trial_pos_y <= e1)

        # Calculate MUA for all, attended, and unattended trials in this quartile
        all_activity = population_mua[quartile_mask].mean(axis=0)
        attn_activity = population_mua[quartile_mask & (trial_attended == 1)]
        unattn_activity = population_mua[quartile_mask & (trial_attended == 0)]
        pval = ttest_ind(attn_activity[:, attention_window_mask].mean(axis=1),
                         unattn_activity[:, attention_window_mask].mean(axis=1)).pvalue

        # Plotting - row 0 shows all quartiles overlaid
        axs[0, col_idx].plot(t_rel_stim, all_activity, label=f'Q{i+1}: [{e0:.1f}, {e1:.1f}]°')

        # Plotting - rows 1-4 show individual quartiles with attention comparison
        axs[i+1, col_idx].plot(t_rel_stim, all_activity, c='gray', alpha=0.5, label='All trials')
        axs[i+1, col_idx].plot(t_rel_stim, attn_activity.mean(axis=0), label='Attended', color='r')
        axs[i+1, col_idx].plot(t_rel_stim, unattn_activity.mean(axis=0), label='Unattended', color='b')
        axs[i+1, col_idx].axvline(x=0, color='k', linestyle='--')
        axs[i+1, col_idx].set_ylim(-.3, 1.3)
        axs[i+1, col_idx].axhline(y=0, color='k', linestyle='--', alpha=0.3, zorder=0)

        # Add counting window with significance
        add_significance_window(axs[i+1, col_idx], ATTENTION_WINDOW, pval)

        axs[i+1, col_idx].set_title(f'Q{i+1}: [{e0:.1f}, {e1:.1f}]°')
        axs[i+1, col_idx].grid(True, alpha=0.2)
        if i == 0:
            axs[i+1, col_idx].legend()

    # Configure top row
    axs[0, col_idx].set_ylabel('Normalized MUA')
    axs[0, col_idx].set_title(f'{monkey.capitalize()} - All Quartiles')
    axs[0, col_idx].legend()
    axs[0, col_idx].grid(True, alpha=0.2)
    axs[0, col_idx].axvline(x=0, color='k', linestyle='--')

# Set x-labels for bottom row
axs[-1, 0].set_xlabel('Time (s)')
axs[-1, 1].set_xlabel('Time (s)')

# Add y-axis label
fig.text(0.04, 0.5, 'Normalized MUA', va='center', rotation='vertical', fontsize=12)
plt.tight_layout(rect=[0.05, 0, 1, 0.99])
if SAVE_FIGS:
    plt.savefig(FIGURE_DIR / 'mua_by_eye_position_quartile.png', dpi=300)
    plt.savefig(FIGURE_DIR / 'mua_by_eye_position_quartile.svg')
plt.show()

print("\nCONCLUSION for Control 2:")
print("   - A robust attention effect (Attended > Unattended) is present within each eye position quartile.")
print("   - Therefore, the V1 attention effect is NOT driven by the small systematic difference in mean eye position.")

#%%
print("""
# =============================================================================
# CONTROL 3: OCULAR DRIFT (PATH LENGTH) ANALYSIS
# =============================================================================

Test whether differences in ocular drift between attention conditions could account
for observed neural differences.

BACKGROUND:
Even during attempted fixation, the eyes exhibit slow drift movements. This drift can:
1. Change the retinal image location continuously
2. Activate different populations of neurons with different receptive fields
3. Create apparent "attention" effects if drift patterns differ between conditions

DRIFT QUANTIFICATION:
Path length = cumulative eye speed during stimulus period. A sensitive measure of ocular instability.

HYPOTHESIS: If attention effects are due to drift differences, then:
1. Attended and unattended trials should have different path lengths
2. Neural activity should vary systematically with path length
3. Attention effects should disappear when controlling for path length
""")


print("\n3. CONTROL 3: Ocular drift (path length) analysis...")
print(f"   - Analysis window: {DRIFT_ANALYSIS_WINDOW[0]}-{DRIFT_ANALYSIS_WINDOW[1]} s")

# Calculate path length statistics for both monkeys
n_bins = 4
path_length_data = {}

for monkey in MONKEYS:
    trial_path_length, edges, mean_att, mean_unatt, pval = calculate_path_length(
        **monkey_data[monkey],
        drift_analysis_window=DRIFT_ANALYSIS_WINDOW
    )

    path_length_data[monkey] = {
        'trial_path_length': trial_path_length,
        'edges': edges,
        'mean_attended': mean_att,
        'mean_unattended': mean_unatt,
        'pval': pval
    }

    print(f'\n{monkey}:')
    print(f'   - Mean attended path length: {mean_att:.2f}')
    print(f'   - Mean unattended path length: {mean_unatt:.2f}')
    print(f'   - T-test for difference in path length: p = {pval:.3f}')
    print(f'   - Path length bin edges (quartiles): {np.round(edges, 2)}')

# Plot the distribution of path lengths for both monkeys (side-by-side)
fig, axes = plt.subplots(1, 2, figsize=(14, 6))

for col_idx, monkey in enumerate(['monkeyN', 'monkeyF']):
    ax = axes[col_idx]
    data = path_length_data[monkey]
    trial_path_length = data['trial_path_length']
    edges = data['edges']
    pval = data['pval']
    mean_att = data['mean_attended']
    mean_unatt = data['mean_unattended']
    trial_attended = monkey_data[monkey]['trial_attended']

    bins = np.linspace(trial_path_length.min(), trial_path_length.max(), 30)
    ax.hist(trial_path_length, bins=bins, color='gray', label='All Trials', alpha=0.6)
    ax.hist(trial_path_length[trial_attended == 1], bins=bins, alpha=0.7, label='Attended', color='r')
    ax.hist(trial_path_length[trial_attended == 0], bins=bins, alpha=0.7, label='Unattended', color='b')

    # Add mean indicators and significance
    ax.scatter([mean_att], [60], color='r', marker='v', s=100, label='Attended Mean', zorder=5)
    ax.scatter([mean_unatt], [60], color='b', marker='v', s=100, label='Unattended Mean', zorder=5)
    significance_connector(mean_att, mean_unatt, 65, 5, 'n.s.' if pval > 0.05 else f'p={pval:.3f}')

    for e in edges:
        ax.axvline(x=e, color='k', linestyle='--', label='Quartile edges' if e == edges[0] else None, alpha=0.5)

    ax.legend()
    ax.set_title(f'{monkey.capitalize()} - Path Lengths ({DRIFT_ANALYSIS_WINDOW[0]}-{DRIFT_ANALYSIS_WINDOW[1]}s)')
    ax.set_xlabel('Path Length (arbitrary units)')
    ax.set_ylabel('Number of Trials')

fig.suptitle('Distribution of Path Lengths', fontsize=16, y=1.00)
plt.tight_layout()
if SAVE_FIGS:
    plt.savefig(FIGURE_DIR / 'path_length_distribution.png', dpi=300)
    plt.savefig(FIGURE_DIR / 'path_length_distribution.svg')
plt.show()

print("\n   - There is no significant difference in path length between attended and unattended trials.")
print("   - Nevertheless, we will check if the attention effect persists within each path length quartile as a stringent control.")

#%%
# Plot MUA for attended vs. unattended trials within each path length quartile
# Layout: 5 rows × 2 columns (MonkeyN left, MonkeyF right)
fig, axs = plt.subplots(n_bins+1, 2, figsize=(14, 12), sharex=True, sharey=True)
fig.suptitle('MUA Conditioned on Path Length', y=0.995, fontsize=16)

for col_idx, monkey in enumerate(['monkeyN', 'monkeyF']):
    data = monkey_data[monkey]
    path_data = path_length_data[monkey]
    population_mua = data['population_mua']
    trial_attended = data['trial_attended']
    t_rel_stim = data['t_rel_stim']
    trial_path_length = path_data['trial_path_length']
    edges = path_data['edges']

    # Calculate attention window mask
    attention_window_mask = (t_rel_stim >= ATTENTION_WINDOW[0]) & (t_rel_stim <= ATTENTION_WINDOW[1])

    for i in range(n_bins):
        e0, e1 = edges[i], edges[i+1]
        # Create a mask for trials within the current path length quartile
        quartile_mask = (trial_path_length >= e0) & (trial_path_length <= e1)

        # Calculate MUA for all, attended, and unattended trials in this quartile
        all_mua = population_mua[quartile_mask].mean(axis=0)
        attended_mua = population_mua[quartile_mask & (trial_attended == 1)].mean(axis=0)
        unattended_mua = population_mua[quartile_mask & (trial_attended == 0)].mean(axis=0)

        pval = ttest_ind(
            population_mua[quartile_mask & (trial_attended == 1)][:, attention_window_mask].mean(axis=1),
            population_mua[quartile_mask & (trial_attended == 0)][:, attention_window_mask].mean(axis=1)
        ).pvalue

        # Plotting - row 0 shows all quartiles overlaid
        axs[0, col_idx].plot(t_rel_stim, all_mua, label=f'Q{i+1}')

        # Plotting - rows 1-4 show individual quartiles with attention comparison
        axs[i+1, col_idx].plot(t_rel_stim, all_mua, c='gray', alpha=0.5, label='All trials')
        axs[i+1, col_idx].plot(t_rel_stim, attended_mua, label='Attended', color='r')
        axs[i+1, col_idx].plot(t_rel_stim, unattended_mua, label='Unattended', color='b')
        axs[i+1, col_idx].axvline(x=0, color='k', linestyle='--')
        axs[i+1, col_idx].grid(True, alpha=0.2)
        axs[i+1, col_idx].axhline(y=0, color='k', linestyle='--', alpha=0.3, zorder=0)

        # Add counting window with significance
        add_significance_window(axs[i+1, col_idx], ATTENTION_WINDOW, pval)

        axs[i+1, col_idx].set_title(f'Q{i+1}: [{edges[i]:.2f}, {edges[i+1]:.2f}]')
        if i == 0:
            axs[i+1, col_idx].legend()

    # Configure top row
    axs[0, col_idx].set_title(f'{monkey.capitalize()} - All Quartiles')
    axs[0, col_idx].legend()
    axs[0, col_idx].grid(True, alpha=0.2)
    axs[0, col_idx].axvline(x=0, color='k', linestyle='--')

# Set x-labels for bottom row
axs[-1, 0].set_xlabel('Time (s)')
axs[-1, 1].set_xlabel('Time (s)')

# Add y-axis label
fig.text(0.04, 0.5, 'Normalized MUA', va='center', rotation='vertical', fontsize=12)
plt.tight_layout(rect=[0.05, 0, 1, 0.99])
if SAVE_FIGS:
    plt.savefig(FIGURE_DIR / 'mua_by_path_length_quartile.png', dpi=300)
    plt.savefig(FIGURE_DIR / 'mua_by_path_length_quartile.svg')
plt.show()

print("""
KEY FINDING: Attention effects persist across all path length quartiles.

INTERPRETATION:
- Although there is a slight modulation of MUA by path length (higher drift = slightly higher MUA),
  the attention effect is robustly present in all quartiles.
- This demonstrates that neural attention effects are not mere artifacts of ocular drift.

CONCLUSION for Control 3: The attentional modulation of V1 multi-unit activity is not driven by
differences in ocular drift between attended and unattended conditions.
""")

print("\n" + "="*70)
print("SUMMARY OF EYE MOVEMENT CONTROLS")
print("="*70)
print("The three comprehensive eye movement controls demonstrate that:")
print("1. MICROSACCADE CONTROL: Attention effects remain in trials without microsaccades.")
print("2. EYE POSITION CONTROL: Attention effects persist within each eye position quartile.")
print("3. DRIFT CONTROL: Attention effects are present across all ocular drift levels.")
print()
print("CONCLUSION:")
print("These controls were unable to explain away the V1 attentional affects as being")
print("due to eye movements during fixation.")
print("="*70)


